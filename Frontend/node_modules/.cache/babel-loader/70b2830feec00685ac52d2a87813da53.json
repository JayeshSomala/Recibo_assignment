{"ast":null,"code":"'use strict';\n\nconst PLUGIN_NAME = 'sha256_password';\n\nconst crypto = require('crypto');\n\nconst {\n  xor\n} = require('../auth_41');\n\nconst REQUEST_SERVER_KEY_PACKET = Buffer.from([1]);\nconst STATE_INITIAL = 0;\nconst STATE_WAIT_SERVER_KEY = 1;\nconst STATE_FINAL = -1;\n\nfunction encrypt(password, scramble, key) {\n  const stage1 = xor(Buffer.from(`${password}\\0`, 'utf8').toString('binary'), scramble.toString('binary'));\n  return crypto.publicEncrypt(key, stage1);\n}\n\nmodule.exports = function () {\n  let pluginOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return _ref => {\n    let {\n      connection\n    } = _ref;\n    let state = 0;\n    let scramble = null;\n    const password = connection.config.password;\n\n    const authWithKey = serverKey => {\n      const _password = encrypt(password, scramble, serverKey);\n\n      state = STATE_FINAL;\n      return _password;\n    };\n\n    return data => {\n      switch (state) {\n        case STATE_INITIAL:\n          scramble = data.slice(0, 20); // if client provides key we can save one extra roundrip on first connection\n\n          if (pluginOptions.serverPublicKey) {\n            return authWithKey(pluginOptions.serverPublicKey);\n          }\n\n          state = STATE_WAIT_SERVER_KEY;\n          return REQUEST_SERVER_KEY_PACKET;\n\n        case STATE_WAIT_SERVER_KEY:\n          if (pluginOptions.onServerPublicKey) {\n            pluginOptions.onServerPublicKey(data);\n          }\n\n          return authWithKey(data);\n\n        case STATE_FINAL:\n          throw new Error(`Unexpected data in AuthMoreData packet received by ${PLUGIN_NAME} plugin in STATE_FINAL state.`);\n      }\n\n      throw new Error(`Unexpected data in AuthMoreData packet received by ${PLUGIN_NAME} plugin in state ${state}`);\n    };\n  };\n};","map":{"version":3,"sources":["C:/Users/jayes/Downloads/react-hook-form-crud-example/src/_helpers/node_modules/mysql2/lib/auth_plugins/sha256_password.js"],"names":["PLUGIN_NAME","crypto","require","xor","REQUEST_SERVER_KEY_PACKET","Buffer","from","STATE_INITIAL","STATE_WAIT_SERVER_KEY","STATE_FINAL","encrypt","password","scramble","key","stage1","toString","publicEncrypt","module","exports","pluginOptions","connection","state","config","authWithKey","serverKey","_password","data","slice","serverPublicKey","onServerPublicKey","Error"],"mappings":"AAAA;;AAEA,MAAMA,WAAW,GAAG,iBAApB;;AACA,MAAMC,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAUD,OAAO,CAAC,YAAD,CAAvB;;AAEA,MAAME,yBAAyB,GAAGC,MAAM,CAACC,IAAP,CAAY,CAAC,CAAD,CAAZ,CAAlC;AAEA,MAAMC,aAAa,GAAG,CAAtB;AACA,MAAMC,qBAAqB,GAAG,CAA9B;AACA,MAAMC,WAAW,GAAG,CAAC,CAArB;;AAEA,SAASC,OAAT,CAAiBC,QAAjB,EAA2BC,QAA3B,EAAqCC,GAArC,EAA0C;AACxC,QAAMC,MAAM,GAAGX,GAAG,CAChBE,MAAM,CAACC,IAAP,CAAa,GAAEK,QAAS,IAAxB,EAA6B,MAA7B,EAAqCI,QAArC,CAA8C,QAA9C,CADgB,EAEhBH,QAAQ,CAACG,QAAT,CAAkB,QAAlB,CAFgB,CAAlB;AAIA,SAAOd,MAAM,CAACe,aAAP,CAAqBH,GAArB,EAA0BC,MAA1B,CAAP;AACD;;AAEDG,MAAM,CAACC,OAAP,GAAiB;AAAA,MAACC,aAAD,uEAAiB,EAAjB;AAAA,SAAwB,QAAoB;AAAA,QAAnB;AAAEC,MAAAA;AAAF,KAAmB;AAC3D,QAAIC,KAAK,GAAG,CAAZ;AACA,QAAIT,QAAQ,GAAG,IAAf;AAEA,UAAMD,QAAQ,GAAGS,UAAU,CAACE,MAAX,CAAkBX,QAAnC;;AAEA,UAAMY,WAAW,GAAGC,SAAS,IAAI;AAC/B,YAAMC,SAAS,GAAGf,OAAO,CAACC,QAAD,EAAWC,QAAX,EAAqBY,SAArB,CAAzB;;AACAH,MAAAA,KAAK,GAAGZ,WAAR;AACA,aAAOgB,SAAP;AACD,KAJD;;AAMA,WAAOC,IAAI,IAAI;AACb,cAAQL,KAAR;AACE,aAAKd,aAAL;AACEK,UAAAA,QAAQ,GAAGc,IAAI,CAACC,KAAL,CAAW,CAAX,EAAc,EAAd,CAAX,CADF,CAEE;;AACA,cAAIR,aAAa,CAACS,eAAlB,EAAmC;AACjC,mBAAOL,WAAW,CAACJ,aAAa,CAACS,eAAf,CAAlB;AACD;;AAEDP,UAAAA,KAAK,GAAGb,qBAAR;AACA,iBAAOJ,yBAAP;;AAEF,aAAKI,qBAAL;AACE,cAAIW,aAAa,CAACU,iBAAlB,EAAqC;AACnCV,YAAAA,aAAa,CAACU,iBAAd,CAAgCH,IAAhC;AACD;;AACD,iBAAOH,WAAW,CAACG,IAAD,CAAlB;;AACF,aAAKjB,WAAL;AACE,gBAAM,IAAIqB,KAAJ,CACH,sDAAqD9B,WAAY,+BAD9D,CAAN;AAjBJ;;AAsBA,YAAM,IAAI8B,KAAJ,CACH,sDAAqD9B,WAAY,oBAAmBqB,KAAM,EADvF,CAAN;AAGD,KA1BD;AA2BD,GAvCgB;AAAA,CAAjB","sourcesContent":["'use strict';\n\nconst PLUGIN_NAME = 'sha256_password';\nconst crypto = require('crypto');\nconst { xor } = require('../auth_41');\n\nconst REQUEST_SERVER_KEY_PACKET = Buffer.from([1]);\n\nconst STATE_INITIAL = 0;\nconst STATE_WAIT_SERVER_KEY = 1;\nconst STATE_FINAL = -1;\n\nfunction encrypt(password, scramble, key) {\n  const stage1 = xor(\n    Buffer.from(`${password}\\0`, 'utf8').toString('binary'),\n    scramble.toString('binary')\n  );\n  return crypto.publicEncrypt(key, stage1);\n}\n\nmodule.exports = (pluginOptions = {}) => ({ connection }) => {\n  let state = 0;\n  let scramble = null;\n\n  const password = connection.config.password;\n\n  const authWithKey = serverKey => {\n    const _password = encrypt(password, scramble, serverKey);\n    state = STATE_FINAL;\n    return _password;\n  };\n\n  return data => {\n    switch (state) {\n      case STATE_INITIAL:\n        scramble = data.slice(0, 20);\n        // if client provides key we can save one extra roundrip on first connection\n        if (pluginOptions.serverPublicKey) {\n          return authWithKey(pluginOptions.serverPublicKey);\n        }\n\n        state = STATE_WAIT_SERVER_KEY;\n        return REQUEST_SERVER_KEY_PACKET;\n\n      case STATE_WAIT_SERVER_KEY:\n        if (pluginOptions.onServerPublicKey) {\n          pluginOptions.onServerPublicKey(data);\n        }\n        return authWithKey(data);\n      case STATE_FINAL:\n        throw new Error(\n          `Unexpected data in AuthMoreData packet received by ${PLUGIN_NAME} plugin in STATE_FINAL state.`\n        );\n    }\n\n    throw new Error(\n      `Unexpected data in AuthMoreData packet received by ${PLUGIN_NAME} plugin in state ${state}`\n    );\n  };\n};\n"]},"metadata":{},"sourceType":"module"}