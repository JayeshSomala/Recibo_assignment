{"ast":null,"code":"import { isValidElement, useRef, useState, useCallback, useEffect, useMemo, createContext, useContext, createElement, cloneElement } from 'react';\n\nvar isHTMLElement = value => value instanceof HTMLElement;\n\nconst EVENTS = {\n  BLUR: 'blur',\n  CHANGE: 'change',\n  INPUT: 'input'\n};\nconst VALIDATION_MODE = {\n  onBlur: 'onBlur',\n  onChange: 'onChange',\n  onSubmit: 'onSubmit',\n  onTouched: 'onTouched',\n  all: 'all'\n};\nconst SELECT = 'select';\nconst UNDEFINED = 'undefined';\nconst INPUT_VALIDATION_RULES = {\n  max: 'max',\n  min: 'min',\n  maxLength: 'maxLength',\n  minLength: 'minLength',\n  pattern: 'pattern',\n  required: 'required',\n  validate: 'validate'\n};\n\nfunction attachEventListeners(_ref, shouldAttachChangeEvent, handleChange) {\n  let {\n    ref\n  } = _ref;\n\n  if (isHTMLElement(ref) && handleChange) {\n    ref.addEventListener(shouldAttachChangeEvent ? EVENTS.CHANGE : EVENTS.INPUT, handleChange);\n    ref.addEventListener(EVENTS.BLUR, handleChange);\n  }\n}\n\nvar isNullOrUndefined = value => value == null;\n\nconst isObjectType = value => typeof value === 'object';\n\nvar isObject = value => !isNullOrUndefined(value) && !Array.isArray(value) && isObjectType(value) && !(value instanceof Date);\n\nvar isKey = value => /^\\w*$/.test(value);\n\nvar compact = value => value.filter(Boolean);\n\nvar stringToPath = input => compact(input.replace(/[\"|']/g, '').replace(/\\[/g, '.').replace(/\\]/g, '').split('.'));\n\nfunction set(object, path, value) {\n  let index = -1;\n  const tempPath = isKey(path) ? [path] : stringToPath(path);\n  const length = tempPath.length;\n  const lastIndex = length - 1;\n\n  while (++index < length) {\n    const key = tempPath[index];\n    let newValue = value;\n\n    if (index !== lastIndex) {\n      const objValue = object[key];\n      newValue = isObject(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};\n    }\n\n    object[key] = newValue;\n    object = object[key];\n  }\n\n  return object;\n}\n\nvar transformToNestObject = function (data) {\n  let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  for (const key in data) {\n    !isKey(key) ? set(value, key, data[key]) : value[key] = data[key];\n  }\n\n  return value;\n};\n\nvar isUndefined = val => val === undefined;\n\nvar get = function () {\n  let obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let path = arguments.length > 1 ? arguments[1] : undefined;\n  let defaultValue = arguments.length > 2 ? arguments[2] : undefined;\n  const result = compact(path.split(/[,[\\].]+?/)).reduce((result, key) => isNullOrUndefined(result) ? result : result[key], obj);\n  return isUndefined(result) || result === obj ? isUndefined(obj[path]) ? defaultValue : obj[path] : result;\n};\n\nvar focusOnErrorField = (fields, fieldErrors) => {\n  for (const key in fields) {\n    if (get(fieldErrors, key)) {\n      const field = fields[key];\n\n      if (field) {\n        if (field.ref.focus && isUndefined(field.ref.focus())) {\n          break;\n        } else if (field.options) {\n          field.options[0].ref.focus();\n          break;\n        }\n      }\n    }\n  }\n};\n\nvar removeAllEventListeners = (ref, validateWithStateUpdate) => {\n  if (isHTMLElement(ref) && ref.removeEventListener) {\n    ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\n  }\n};\n\nconst defaultReturn = {\n  isValid: false,\n  value: null\n};\n\nvar getRadioValue = options => Array.isArray(options) ? options.reduce((previous, option) => option && option.ref.checked ? {\n  isValid: true,\n  value: option.ref.value\n} : previous, defaultReturn) : defaultReturn;\n\nvar getMultipleSelectValue = options => [...options].filter(_ref2 => {\n  let {\n    selected\n  } = _ref2;\n  return selected;\n}).map(_ref3 => {\n  let {\n    value\n  } = _ref3;\n  return value;\n});\n\nvar isRadioInput = element => element.type === 'radio';\n\nvar isFileInput = element => element.type === 'file';\n\nvar isCheckBoxInput = element => element.type === 'checkbox';\n\nvar isMultipleSelect = element => element.type === `${SELECT}-multiple`;\n\nconst defaultResult = {\n  value: false,\n  isValid: false\n};\nconst validResult = {\n  value: true,\n  isValid: true\n};\n\nvar getCheckboxValue = options => {\n  if (Array.isArray(options)) {\n    if (options.length > 1) {\n      const values = options.filter(option => option && option.ref.checked).map(_ref4 => {\n        let {\n          ref: {\n            value\n          }\n        } = _ref4;\n        return value;\n      });\n      return {\n        value: values,\n        isValid: !!values.length\n      };\n    }\n\n    const {\n      checked,\n      value,\n      attributes\n    } = options[0].ref;\n    return checked ? attributes && !isUndefined(attributes.value) ? isUndefined(value) || value === '' ? validResult : {\n      value: value,\n      isValid: true\n    } : validResult : defaultResult;\n  }\n\n  return defaultResult;\n};\n\nfunction getFieldValue(fieldsRef, name, shallowFieldsStateRef, excludeDisabled, shouldKeepRawValue) {\n  const field = fieldsRef.current[name];\n\n  if (field) {\n    const {\n      ref: {\n        value,\n        disabled\n      },\n      ref,\n      valueAsNumber,\n      valueAsDate,\n      setValueAs\n    } = field;\n\n    if (disabled && excludeDisabled) {\n      return;\n    }\n\n    if (isFileInput(ref)) {\n      return ref.files;\n    }\n\n    if (isRadioInput(ref)) {\n      return getRadioValue(field.options).value;\n    }\n\n    if (isMultipleSelect(ref)) {\n      return getMultipleSelectValue(ref.options);\n    }\n\n    if (isCheckBoxInput(ref)) {\n      return getCheckboxValue(field.options).value;\n    }\n\n    return shouldKeepRawValue ? value : valueAsNumber ? value === '' ? NaN : +value : valueAsDate ? ref.valueAsDate : setValueAs ? setValueAs(value) : value;\n  }\n\n  if (shallowFieldsStateRef) {\n    return get(shallowFieldsStateRef.current, name);\n  }\n}\n\nfunction isDetached(element) {\n  if (!element) {\n    return true;\n  }\n\n  if (!(element instanceof HTMLElement) || element.nodeType === Node.DOCUMENT_NODE) {\n    return false;\n  }\n\n  return isDetached(element.parentNode);\n}\n\nvar isEmptyObject = value => isObject(value) && !Object.keys(value).length;\n\nvar isBoolean = value => typeof value === 'boolean';\n\nfunction baseGet(object, updatePath) {\n  const length = updatePath.slice(0, -1).length;\n  let index = 0;\n\n  while (index < length) {\n    object = isUndefined(object) ? index++ : object[updatePath[index++]];\n  }\n\n  return object;\n}\n\nfunction unset(object, path) {\n  const updatePath = isKey(path) ? [path] : stringToPath(path);\n  const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\n  const key = updatePath[updatePath.length - 1];\n  let previousObjRef;\n\n  if (childObject) {\n    delete childObject[key];\n  }\n\n  for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\n    let index = -1;\n    let objectRef;\n    const currentPaths = updatePath.slice(0, -(k + 1));\n    const currentPathsLength = currentPaths.length - 1;\n\n    if (k > 0) {\n      previousObjRef = object;\n    }\n\n    while (++index < currentPaths.length) {\n      const item = currentPaths[index];\n      objectRef = objectRef ? objectRef[item] : object[item];\n\n      if (currentPathsLength === index && (isObject(objectRef) && isEmptyObject(objectRef) || Array.isArray(objectRef) && !objectRef.filter(data => isObject(data) && !isEmptyObject(data) || isBoolean(data)).length)) {\n        previousObjRef ? delete previousObjRef[item] : delete object[item];\n      }\n\n      previousObjRef = objectRef;\n    }\n  }\n\n  return object;\n}\n\nconst isSameRef = (fieldValue, ref) => fieldValue && fieldValue.ref === ref;\n\nfunction findRemovedFieldAndRemoveListener(fieldsRef, handleChange, field, shallowFieldsStateRef, shouldUnregister, forceDelete) {\n  const {\n    ref,\n    ref: {\n      name\n    }\n  } = field;\n  const fieldRef = fieldsRef.current[name];\n\n  if (!shouldUnregister) {\n    const value = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\n    !isUndefined(value) && set(shallowFieldsStateRef.current, name, value);\n  }\n\n  if (!ref.type || !fieldRef) {\n    delete fieldsRef.current[name];\n    return;\n  }\n\n  if (isRadioInput(ref) || isCheckBoxInput(ref)) {\n    if (Array.isArray(fieldRef.options) && fieldRef.options.length) {\n      compact(fieldRef.options).forEach(function () {\n        let option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let index = arguments.length > 1 ? arguments[1] : undefined;\n\n        if (isDetached(option.ref) && isSameRef(option, option.ref) || forceDelete) {\n          removeAllEventListeners(option.ref, handleChange);\n          unset(fieldRef.options, `[${index}]`);\n        }\n      });\n\n      if (fieldRef.options && !compact(fieldRef.options).length) {\n        delete fieldsRef.current[name];\n      }\n    } else {\n      delete fieldsRef.current[name];\n    }\n  } else if (isDetached(ref) && isSameRef(fieldRef, ref) || forceDelete) {\n    removeAllEventListeners(ref, handleChange);\n    delete fieldsRef.current[name];\n  }\n}\n\nvar isPrimitive = value => isNullOrUndefined(value) || !isObjectType(value);\n\nfunction deepMerge(target, source) {\n  if (isPrimitive(target) || isPrimitive(source)) {\n    return source;\n  }\n\n  for (const key in source) {\n    const targetValue = target[key];\n    const sourceValue = source[key];\n\n    try {\n      target[key] = isObject(targetValue) && isObject(sourceValue) || Array.isArray(targetValue) && Array.isArray(sourceValue) ? deepMerge(targetValue, sourceValue) : sourceValue;\n    } catch (_a) {}\n  }\n\n  return target;\n}\n\nfunction deepEqual(object1, object2, isErrorObject) {\n  if (isPrimitive(object1) || isPrimitive(object2) || object1 instanceof Date || object2 instanceof Date) {\n    return object1 === object2;\n  }\n\n  if (!isValidElement(object1)) {\n    const keys1 = Object.keys(object1);\n    const keys2 = Object.keys(object2);\n\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n\n    for (const key of keys1) {\n      const val1 = object1[key];\n\n      if (!(isErrorObject && key === 'ref')) {\n        const val2 = object2[key];\n\n        if ((isObject(val1) || Array.isArray(val1)) && (isObject(val2) || Array.isArray(val2)) ? !deepEqual(val1, val2, isErrorObject) : val1 !== val2) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction setDirtyFields(values, defaultValues, dirtyFields, parentNode, parentName) {\n  let index = -1;\n\n  while (++index < values.length) {\n    for (const key in values[index]) {\n      if (Array.isArray(values[index][key])) {\n        !dirtyFields[index] && (dirtyFields[index] = {});\n        dirtyFields[index][key] = [];\n        setDirtyFields(values[index][key], get(defaultValues[index] || {}, key, []), dirtyFields[index][key], dirtyFields[index], key);\n      } else {\n        deepEqual(get(defaultValues[index] || {}, key), values[index][key]) ? set(dirtyFields[index] || {}, key) : dirtyFields[index] = Object.assign(Object.assign({}, dirtyFields[index]), {\n          [key]: true\n        });\n      }\n    }\n\n    parentNode && !dirtyFields.length && delete parentNode[parentName];\n  }\n\n  return dirtyFields;\n}\n\nvar setFieldArrayDirtyFields = (values, defaultValues, dirtyFields) => deepMerge(setDirtyFields(values, defaultValues, dirtyFields.slice(0, values.length)), setDirtyFields(defaultValues, values, dirtyFields.slice(0, values.length)));\n\nvar isString = value => typeof value === 'string';\n\nvar getFieldsValues = (fieldsRef, shallowFieldsState, shouldUnregister, excludeDisabled, search) => {\n  const output = {};\n\n  for (const name in fieldsRef.current) {\n    if (isUndefined(search) || (isString(search) ? name.startsWith(search) : Array.isArray(search) && search.find(data => name.startsWith(data)))) {\n      output[name] = getFieldValue(fieldsRef, name, undefined, excludeDisabled);\n    }\n  }\n\n  return shouldUnregister ? transformToNestObject(output) : deepMerge(shallowFieldsState, transformToNestObject(output));\n};\n\nvar isErrorStateChanged = _ref5 => {\n  let {\n    errors,\n    name,\n    error,\n    validFields,\n    fieldsWithValidation\n  } = _ref5;\n  const isValid = isUndefined(error);\n  const previousError = get(errors, name);\n  return isValid && !!previousError || !isValid && !deepEqual(previousError, error, true) || isValid && get(fieldsWithValidation, name) && !get(validFields, name);\n};\n\nvar isRegex = value => value instanceof RegExp;\n\nvar getValueAndMessage = validationData => isObject(validationData) && !isRegex(validationData) ? validationData : {\n  value: validationData,\n  message: ''\n};\n\nvar isFunction = value => typeof value === 'function';\n\nvar isMessage = value => isString(value) || isValidElement(value);\n\nfunction getValidateError(result, ref) {\n  let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'validate';\n\n  if (isMessage(result) || isBoolean(result) && !result) {\n    return {\n      type,\n      message: isMessage(result) ? result : '',\n      ref\n    };\n  }\n}\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria ? Object.assign(Object.assign({}, errors[name]), {\n  types: Object.assign(Object.assign({}, errors[name] && errors[name].types ? errors[name].types : {}), {\n    [type]: message || true\n  })\n}) : {};\n\nvar validateField = async (fieldsRef, validateAllFieldCriteria, _ref6, shallowFieldsStateRef) => {\n  let {\n    ref,\n    ref: {\n      value\n    },\n    options,\n    required,\n    maxLength,\n    minLength,\n    min,\n    max,\n    pattern,\n    validate\n  } = _ref6;\n  const name = ref.name;\n  const error = {};\n  const isRadio = isRadioInput(ref);\n  const isCheckBox = isCheckBoxInput(ref);\n  const isRadioOrCheckbox = isRadio || isCheckBox;\n  const isEmpty = value === '';\n  const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\n\n  const getMinMaxMessage = function (exceedMax, maxLengthMessage, minLengthMessage) {\n    let maxType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : INPUT_VALIDATION_RULES.maxLength;\n    let minType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : INPUT_VALIDATION_RULES.minLength;\n    const message = exceedMax ? maxLengthMessage : minLengthMessage;\n    error[name] = Object.assign({\n      type: exceedMax ? maxType : minType,\n      message,\n      ref\n    }, exceedMax ? appendErrorsCurry(maxType, message) : appendErrorsCurry(minType, message));\n  };\n\n  if (required && (!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value)) || isBoolean(value) && !value || isCheckBox && !getCheckboxValue(options).isValid || isRadio && !getRadioValue(options).isValid)) {\n    const {\n      value,\n      message\n    } = isMessage(required) ? {\n      value: !!required,\n      message: required\n    } : getValueAndMessage(required);\n\n    if (value) {\n      error[name] = Object.assign({\n        type: INPUT_VALIDATION_RULES.required,\n        message,\n        ref: isRadioOrCheckbox ? ((fieldsRef.current[name].options || [])[0] || {}).ref : ref\n      }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));\n\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if ((!isNullOrUndefined(min) || !isNullOrUndefined(max)) && value !== '') {\n    let exceedMax;\n    let exceedMin;\n    const maxOutput = getValueAndMessage(max);\n    const minOutput = getValueAndMessage(min);\n\n    if (!isNaN(value)) {\n      const valueNumber = ref.valueAsNumber || parseFloat(value);\n\n      if (!isNullOrUndefined(maxOutput.value)) {\n        exceedMax = valueNumber > maxOutput.value;\n      }\n\n      if (!isNullOrUndefined(minOutput.value)) {\n        exceedMin = valueNumber < minOutput.value;\n      }\n    } else {\n      const valueDate = ref.valueAsDate || new Date(value);\n\n      if (isString(maxOutput.value)) {\n        exceedMax = valueDate > new Date(maxOutput.value);\n      }\n\n      if (isString(minOutput.value)) {\n        exceedMin = valueDate < new Date(minOutput.value);\n      }\n    }\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\n\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (isString(value) && !isEmpty && (maxLength || minLength)) {\n    const maxLengthOutput = getValueAndMessage(maxLength);\n    const minLengthOutput = getValueAndMessage(minLength);\n    const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && value.length > maxLengthOutput.value;\n    const exceedMin = !isNullOrUndefined(minLengthOutput.value) && value.length < minLengthOutput.value;\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\n\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (isString(value) && pattern && !isEmpty) {\n    const {\n      value: patternValue,\n      message\n    } = getValueAndMessage(pattern);\n\n    if (isRegex(patternValue) && !patternValue.test(value)) {\n      error[name] = Object.assign({\n        type: INPUT_VALIDATION_RULES.pattern,\n        message,\n        ref\n      }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message));\n\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (validate) {\n    const fieldValue = getFieldValue(fieldsRef, name, shallowFieldsStateRef, false, true);\n    const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\n\n    if (isFunction(validate)) {\n      const result = await validate(fieldValue);\n      const validateError = getValidateError(result, validateRef);\n\n      if (validateError) {\n        error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\n\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    } else if (isObject(validate)) {\n      let validationResult = {};\n\n      for (const [key, validateFunction] of Object.entries(validate)) {\n        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\n          break;\n        }\n\n        const validateResult = await validateFunction(fieldValue);\n        const validateError = getValidateError(validateResult, validateRef, key);\n\n        if (validateError) {\n          validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\n\n          if (validateAllFieldCriteria) {\n            error[name] = validationResult;\n          }\n        }\n      }\n\n      if (!isEmptyObject(validationResult)) {\n        error[name] = Object.assign({\n          ref: validateRef\n        }, validationResult);\n\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    }\n  }\n\n  return error;\n};\n\nconst getPath = function (rootPath, values) {\n  let paths = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n  for (const property in values) {\n    const rootName = rootPath + (isObject(values) ? `.${property}` : `[${property}]`);\n    isPrimitive(values[property]) ? paths.push(rootName) : getPath(rootName, values[property], paths);\n  }\n\n  return paths;\n};\n\nvar assignWatchFields = (fieldValues, fieldName, watchFields, inputValue, isSingleField) => {\n  let value = undefined;\n  watchFields.add(fieldName);\n\n  if (!isEmptyObject(fieldValues)) {\n    value = get(fieldValues, fieldName);\n\n    if (isObject(value) || Array.isArray(value)) {\n      getPath(fieldName, value).forEach(name => watchFields.add(name));\n    }\n  }\n\n  return isUndefined(value) ? isSingleField ? inputValue : get(inputValue, fieldName) : value;\n};\n\nvar skipValidation = _ref7 => {\n  let {\n    isOnBlur,\n    isOnChange,\n    isOnTouch,\n    isTouched,\n    isReValidateOnBlur,\n    isReValidateOnChange,\n    isBlurEvent,\n    isSubmitted,\n    isOnAll\n  } = _ref7;\n\n  if (isOnAll) {\n    return false;\n  } else if (!isSubmitted && isOnTouch) {\n    return !(isTouched || isBlurEvent);\n  } else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\n    return !isBlurEvent;\n  } else if (isSubmitted ? isReValidateOnChange : isOnChange) {\n    return isBlurEvent;\n  }\n\n  return true;\n};\n\nvar getFieldArrayParentName = name => name.substring(0, name.indexOf('['));\n\nconst isMatchFieldArrayName = (name, searchName) => RegExp(`^${searchName}([|.)\\\\d+`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]')).test(name);\n\nvar isNameInFieldArray = (names, name) => [...names].some(current => isMatchFieldArrayName(name, current));\n\nvar isSelectInput = element => element.type === `${SELECT}-one`;\n\nfunction onDomRemove(fieldsRef, removeFieldEventListenerAndRef) {\n  const observer = new MutationObserver(() => {\n    for (const field of Object.values(fieldsRef.current)) {\n      if (field && field.options) {\n        for (const option of field.options) {\n          if (option && option.ref && isDetached(option.ref)) {\n            removeFieldEventListenerAndRef(field);\n          }\n        }\n      } else if (field && isDetached(field.ref)) {\n        removeFieldEventListenerAndRef(field);\n      }\n    }\n  });\n  observer.observe(window.document, {\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\n\nvar isWeb = typeof window !== UNDEFINED && typeof document !== UNDEFINED;\n\nfunction cloneObject(data) {\n  var _a;\n\n  let copy;\n\n  if (isPrimitive(data) || isWeb && (data instanceof File || isHTMLElement(data))) {\n    return data;\n  }\n\n  if (!['Set', 'Map', 'Object', 'Date', 'Array'].includes((_a = data.constructor) === null || _a === void 0 ? void 0 : _a.name)) {\n    return data;\n  }\n\n  if (data instanceof Date) {\n    copy = new Date(data.getTime());\n    return copy;\n  }\n\n  if (data instanceof Set) {\n    copy = new Set();\n\n    for (const item of data) {\n      copy.add(item);\n    }\n\n    return copy;\n  }\n\n  if (data instanceof Map) {\n    copy = new Map();\n\n    for (const key of data.keys()) {\n      copy.set(key, cloneObject(data.get(key)));\n    }\n\n    return copy;\n  }\n\n  copy = Array.isArray(data) ? [] : {};\n\n  for (const key in data) {\n    copy[key] = cloneObject(data[key]);\n  }\n\n  return copy;\n}\n\nvar modeChecker = mode => ({\n  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n  isOnBlur: mode === VALIDATION_MODE.onBlur,\n  isOnChange: mode === VALIDATION_MODE.onChange,\n  isOnAll: mode === VALIDATION_MODE.all,\n  isOnTouch: mode === VALIDATION_MODE.onTouched\n});\n\nvar isRadioOrCheckboxFunction = ref => isRadioInput(ref) || isCheckBoxInput(ref);\n\nconst isWindowUndefined = typeof window === UNDEFINED;\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\n\nfunction useForm() {\n  let {\n    mode = VALIDATION_MODE.onSubmit,\n    reValidateMode = VALIDATION_MODE.onChange,\n    resolver,\n    context,\n    defaultValues = {},\n    shouldFocusError = true,\n    shouldUnregister = true,\n    criteriaMode\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const fieldsRef = useRef({});\n  const fieldArrayDefaultValuesRef = useRef({});\n  const fieldArrayValuesRef = useRef({});\n  const watchFieldsRef = useRef(new Set());\n  const useWatchFieldsRef = useRef({});\n  const useWatchRenderFunctionsRef = useRef({});\n  const fieldsWithValidationRef = useRef({});\n  const validFieldsRef = useRef({});\n  const defaultValuesRef = useRef(defaultValues);\n  const isUnMount = useRef(false);\n  const isWatchAllRef = useRef(false);\n  const handleChangeRef = useRef();\n  const shallowFieldsStateRef = useRef({});\n  const resetFieldArrayFunctionRef = useRef({});\n  const contextRef = useRef(context);\n  const resolverRef = useRef(resolver);\n  const fieldArrayNamesRef = useRef(new Set());\n  const modeRef = useRef(modeChecker(mode));\n  const {\n    isOnSubmit,\n    isOnTouch\n  } = modeRef.current;\n  const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\n  const [formState, setFormState] = useState({\n    isDirty: false,\n    isValidating: false,\n    dirtyFields: {},\n    isSubmitted: false,\n    submitCount: 0,\n    touched: {},\n    isSubmitting: false,\n    isSubmitSuccessful: false,\n    isValid: !isOnSubmit,\n    errors: {}\n  });\n  const readFormStateRef = useRef({\n    isDirty: !isProxyEnabled,\n    dirtyFields: !isProxyEnabled,\n    touched: !isProxyEnabled || isOnTouch,\n    isValidating: !isProxyEnabled,\n    isSubmitting: !isProxyEnabled,\n    isValid: !isProxyEnabled\n  });\n  const formStateRef = useRef(formState);\n  const observerRef = useRef();\n  const {\n    isOnBlur: isReValidateOnBlur,\n    isOnChange: isReValidateOnChange\n  } = useRef(modeChecker(reValidateMode)).current;\n  contextRef.current = context;\n  resolverRef.current = resolver;\n  formStateRef.current = formState;\n  shallowFieldsStateRef.current = shouldUnregister ? {} : isEmptyObject(shallowFieldsStateRef.current) ? cloneObject(defaultValues) : shallowFieldsStateRef.current;\n  const updateFormState = useCallback(function () {\n    let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!isUnMount.current) {\n      formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), state);\n      setFormState(formStateRef.current);\n    }\n  }, []);\n\n  const updateIsValidating = () => readFormStateRef.current.isValidating && updateFormState({\n    isValidating: true\n  });\n\n  const shouldRenderBaseOnError = useCallback(function (name, error) {\n    let shouldRender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let isValid = arguments.length > 4 ? arguments[4] : undefined;\n    let shouldReRender = shouldRender || isErrorStateChanged({\n      errors: formStateRef.current.errors,\n      error,\n      name,\n      validFields: validFieldsRef.current,\n      fieldsWithValidation: fieldsWithValidationRef.current\n    });\n    const previousError = get(formStateRef.current.errors, name);\n\n    if (error) {\n      unset(validFieldsRef.current, name);\n      shouldReRender = shouldReRender || !previousError || !deepEqual(previousError, error, true);\n      set(formStateRef.current.errors, name, error);\n    } else {\n      if (get(fieldsWithValidationRef.current, name) || resolverRef.current) {\n        set(validFieldsRef.current, name, true);\n        shouldReRender = shouldReRender || previousError;\n      }\n\n      unset(formStateRef.current.errors, name);\n    }\n\n    if (shouldReRender && !isNullOrUndefined(shouldRender) || !isEmptyObject(state) || readFormStateRef.current.isValidating) {\n      updateFormState(Object.assign(Object.assign(Object.assign({}, state), resolverRef.current ? {\n        isValid: !!isValid\n      } : {}), {\n        isValidating: false\n      }));\n    }\n  }, []);\n  const setFieldValue = useCallback((name, rawValue) => {\n    const {\n      ref,\n      options\n    } = fieldsRef.current[name];\n    const value = isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue) ? '' : rawValue;\n\n    if (isRadioInput(ref)) {\n      (options || []).forEach(_ref8 => {\n        let {\n          ref: radioRef\n        } = _ref8;\n        return radioRef.checked = radioRef.value === value;\n      });\n    } else if (isFileInput(ref) && !isString(value)) {\n      ref.files = value;\n    } else if (isMultipleSelect(ref)) {\n      [...ref.options].forEach(selectRef => selectRef.selected = value.includes(selectRef.value));\n    } else if (isCheckBoxInput(ref) && options) {\n      options.length > 1 ? options.forEach(_ref9 => {\n        let {\n          ref: checkboxRef\n        } = _ref9;\n        return checkboxRef.checked = Array.isArray(value) ? !!value.find(data => data === checkboxRef.value) : value === checkboxRef.value;\n      }) : options[0].ref.checked = !!value;\n    } else {\n      ref.value = value;\n    }\n  }, []);\n  const isFormDirty = useCallback((name, data) => {\n    if (readFormStateRef.current.isDirty) {\n      const formValues = getValues();\n      name && data && set(formValues, name, data);\n      return !deepEqual(formValues, defaultValuesRef.current);\n    }\n\n    return false;\n  }, []);\n  const updateAndGetDirtyState = useCallback(function (name) {\n    let shouldRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (readFormStateRef.current.isDirty || readFormStateRef.current.dirtyFields) {\n      const isFieldDirty = !deepEqual(get(defaultValuesRef.current, name), getFieldValue(fieldsRef, name, shallowFieldsStateRef));\n      const isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\n      const previousIsDirty = formStateRef.current.isDirty;\n      isFieldDirty ? set(formStateRef.current.dirtyFields, name, true) : unset(formStateRef.current.dirtyFields, name);\n      const state = {\n        isDirty: isFormDirty(),\n        dirtyFields: formStateRef.current.dirtyFields\n      };\n      const isChanged = readFormStateRef.current.isDirty && previousIsDirty !== state.isDirty || readFormStateRef.current.dirtyFields && isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name);\n      isChanged && shouldRender && updateFormState(state);\n      return isChanged ? state : {};\n    }\n\n    return {};\n  }, []);\n  const executeValidation = useCallback(async (name, skipReRender) => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!fieldsRef.current[name]) {\n        console.warn('📋 Field is missing with `name` attribute: ', name);\n        return false;\n      }\n    }\n\n    const error = (await validateField(fieldsRef, isValidateAllFieldCriteria, fieldsRef.current[name], shallowFieldsStateRef))[name];\n    shouldRenderBaseOnError(name, error, skipReRender);\n    return isUndefined(error);\n  }, [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\n  const executeSchemaOrResolverValidation = useCallback(async names => {\n    const {\n      errors\n    } = await resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);\n    const previousFormIsValid = formStateRef.current.isValid;\n\n    if (Array.isArray(names)) {\n      const isInputsValid = names.map(name => {\n        const error = get(errors, name);\n        error ? set(formStateRef.current.errors, name, error) : unset(formStateRef.current.errors, name);\n        return !error;\n      }).every(Boolean);\n      updateFormState({\n        isValid: isEmptyObject(errors),\n        isValidating: false\n      });\n      return isInputsValid;\n    } else {\n      const error = get(errors, names);\n      shouldRenderBaseOnError(names, error, previousFormIsValid !== isEmptyObject(errors), {}, isEmptyObject(errors));\n      return !error;\n    }\n  }, [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\n  const trigger = useCallback(async name => {\n    const fields = name || Object.keys(fieldsRef.current);\n    updateIsValidating();\n\n    if (resolverRef.current) {\n      return executeSchemaOrResolverValidation(fields);\n    }\n\n    if (Array.isArray(fields)) {\n      !name && (formStateRef.current.errors = {});\n      const result = await Promise.all(fields.map(async data => await executeValidation(data, null)));\n      updateFormState({\n        isValidating: false\n      });\n      return result.every(Boolean);\n    }\n\n    return await executeValidation(fields);\n  }, [executeSchemaOrResolverValidation, executeValidation]);\n  const setInternalValues = useCallback((name, value, _ref10) => {\n    let {\n      shouldDirty,\n      shouldValidate\n    } = _ref10;\n    const data = {};\n    set(data, name, value);\n\n    for (const fieldName of getPath(name, value)) {\n      if (fieldsRef.current[fieldName]) {\n        setFieldValue(fieldName, get(data, fieldName));\n        shouldDirty && updateAndGetDirtyState(fieldName);\n        shouldValidate && trigger(fieldName);\n      }\n    }\n  }, [trigger, setFieldValue, updateAndGetDirtyState]);\n  const setInternalValue = useCallback((name, value, config) => {\n    !shouldUnregister && !isPrimitive(value) && set(shallowFieldsStateRef.current, name, Array.isArray(value) ? [...value] : Object.assign({}, value));\n\n    if (fieldsRef.current[name]) {\n      setFieldValue(name, value);\n      config.shouldDirty && updateAndGetDirtyState(name);\n      config.shouldValidate && trigger(name);\n    } else if (!isPrimitive(value)) {\n      setInternalValues(name, value, config);\n\n      if (fieldArrayNamesRef.current.has(name)) {\n        const parentName = getFieldArrayParentName(name) || name;\n        set(fieldArrayDefaultValuesRef.current, name, value);\n        resetFieldArrayFunctionRef.current[parentName]({\n          [parentName]: get(fieldArrayDefaultValuesRef.current, parentName)\n        });\n\n        if ((readFormStateRef.current.isDirty || readFormStateRef.current.dirtyFields) && config.shouldDirty) {\n          set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(value, get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\n          updateFormState({\n            isDirty: !deepEqual(Object.assign(Object.assign({}, getValues()), {\n              [name]: value\n            }), defaultValuesRef.current)\n          });\n        }\n      }\n    }\n\n    !shouldUnregister && set(shallowFieldsStateRef.current, name, value);\n  }, [updateAndGetDirtyState, setFieldValue, setInternalValues]);\n\n  const isFieldWatched = name => isWatchAllRef.current || watchFieldsRef.current.has(name) || watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\n\n  const renderWatchedInputs = name => {\n    let found = true;\n\n    if (!isEmptyObject(useWatchFieldsRef.current)) {\n      for (const key in useWatchFieldsRef.current) {\n        if (!name || !useWatchFieldsRef.current[key].size || useWatchFieldsRef.current[key].has(name) || useWatchFieldsRef.current[key].has(getFieldArrayParentName(name))) {\n          useWatchRenderFunctionsRef.current[key]();\n          found = false;\n        }\n      }\n    }\n\n    return found;\n  };\n\n  function setValue(name, value, config) {\n    setInternalValue(name, value, config || {});\n    isFieldWatched(name) && updateFormState();\n    renderWatchedInputs(name);\n  }\n\n  handleChangeRef.current = handleChangeRef.current ? handleChangeRef.current : async _ref11 => {\n    let {\n      type,\n      target\n    } = _ref11;\n    let name = target.name;\n    const field = fieldsRef.current[name];\n    let error;\n    let isValid;\n\n    if (field) {\n      const isBlurEvent = type === EVENTS.BLUR;\n      const shouldSkipValidation = skipValidation(Object.assign({\n        isBlurEvent,\n        isReValidateOnChange,\n        isReValidateOnBlur,\n        isTouched: !!get(formStateRef.current.touched, name),\n        isSubmitted: formStateRef.current.isSubmitted\n      }, modeRef.current));\n      let state = updateAndGetDirtyState(name, false);\n      let shouldRender = !isEmptyObject(state) || !isBlurEvent && isFieldWatched(name);\n\n      if (isBlurEvent && !get(formStateRef.current.touched, name) && readFormStateRef.current.touched) {\n        set(formStateRef.current.touched, name, true);\n        state = Object.assign(Object.assign({}, state), {\n          touched: formStateRef.current.touched\n        });\n      }\n\n      if (!shouldUnregister && isCheckBoxInput(target)) {\n        set(shallowFieldsStateRef.current, name, getFieldValue(fieldsRef, name));\n      }\n\n      if (shouldSkipValidation) {\n        !isBlurEvent && renderWatchedInputs(name);\n        return (!isEmptyObject(state) || shouldRender && isEmptyObject(state)) && updateFormState(state);\n      }\n\n      updateIsValidating();\n\n      if (resolverRef.current) {\n        const {\n          errors\n        } = await resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);\n        const previousFormIsValid = formStateRef.current.isValid;\n        error = get(errors, name);\n\n        if (isCheckBoxInput(target) && !error && resolverRef.current) {\n          const parentNodeName = getFieldArrayParentName(name);\n          const currentError = get(errors, parentNodeName, {});\n          currentError.type && currentError.message && (error = currentError);\n\n          if (parentNodeName && (currentError || get(formStateRef.current.errors, parentNodeName))) {\n            name = parentNodeName;\n          }\n        }\n\n        isValid = isEmptyObject(errors);\n        previousFormIsValid !== isValid && (shouldRender = true);\n      } else {\n        error = (await validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef))[name];\n      }\n\n      !isBlurEvent && renderWatchedInputs(name);\n      shouldRenderBaseOnError(name, error, shouldRender, state, isValid);\n    }\n  };\n\n  function setFieldArrayDefaultValues(data) {\n    if (!shouldUnregister) {\n      let copy = cloneObject(data);\n\n      for (const value of fieldArrayNamesRef.current) {\n        if (isKey(value) && !copy[value]) {\n          copy = Object.assign(Object.assign({}, copy), {\n            [value]: []\n          });\n        }\n      }\n\n      return copy;\n    }\n\n    return data;\n  }\n\n  function getValues(payload) {\n    if (isString(payload)) {\n      return getFieldValue(fieldsRef, payload, shallowFieldsStateRef);\n    }\n\n    if (Array.isArray(payload)) {\n      const data = {};\n\n      for (const name of payload) {\n        set(data, name, getFieldValue(fieldsRef, name, shallowFieldsStateRef));\n      }\n\n      return data;\n    }\n\n    return setFieldArrayDefaultValues(getFieldsValues(fieldsRef, cloneObject(shallowFieldsStateRef.current), shouldUnregister));\n  }\n\n  const validateResolver = useCallback(async function () {\n    let values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const newDefaultValues = isEmptyObject(fieldsRef.current) ? defaultValuesRef.current : {};\n    const {\n      errors\n    } = (await resolverRef.current(Object.assign(Object.assign(Object.assign({}, newDefaultValues), getValues()), values), contextRef.current, isValidateAllFieldCriteria)) || {};\n    const isValid = isEmptyObject(errors);\n    formStateRef.current.isValid !== isValid && updateFormState({\n      isValid\n    });\n  }, [isValidateAllFieldCriteria]);\n  const removeFieldEventListener = useCallback((field, forceDelete) => {\n    findRemovedFieldAndRemoveListener(fieldsRef, handleChangeRef.current, field, shallowFieldsStateRef, shouldUnregister, forceDelete);\n\n    if (shouldUnregister) {\n      unset(validFieldsRef.current, field.ref.name);\n      unset(fieldsWithValidationRef.current, field.ref.name);\n    }\n  }, [shouldUnregister]);\n  const updateWatchedValue = useCallback(name => {\n    if (isWatchAllRef.current) {\n      updateFormState();\n    } else {\n      for (const watchField of watchFieldsRef.current) {\n        if (watchField.startsWith(name)) {\n          updateFormState();\n          break;\n        }\n      }\n\n      renderWatchedInputs(name);\n    }\n  }, []);\n  const removeFieldEventListenerAndRef = useCallback((field, forceDelete) => {\n    if (field) {\n      removeFieldEventListener(field, forceDelete);\n\n      if (shouldUnregister && !compact(field.options || []).length) {\n        unset(formStateRef.current.errors, field.ref.name);\n        set(formStateRef.current.dirtyFields, field.ref.name, true);\n        updateFormState({\n          isDirty: isFormDirty()\n        });\n        readFormStateRef.current.isValid && resolverRef.current && validateResolver();\n        updateWatchedValue(field.ref.name);\n      }\n    }\n  }, [validateResolver, removeFieldEventListener]);\n\n  function clearErrors(name) {\n    name && (Array.isArray(name) ? name : [name]).forEach(inputName => fieldsRef.current[inputName] && isKey(inputName) ? delete formStateRef.current.errors[inputName] : unset(formStateRef.current.errors, inputName));\n    updateFormState({\n      errors: name ? formStateRef.current.errors : {}\n    });\n  }\n\n  function setError(name, error) {\n    const ref = (fieldsRef.current[name] || {}).ref;\n    set(formStateRef.current.errors, name, Object.assign(Object.assign({}, error), {\n      ref\n    }));\n    updateFormState({\n      isValid: false\n    });\n    error.shouldFocus && ref && ref.focus && ref.focus();\n  }\n\n  const watchInternal = useCallback((fieldNames, defaultValue, watchId) => {\n    const watchFields = watchId ? useWatchFieldsRef.current[watchId] : watchFieldsRef.current;\n    let fieldValues = getFieldsValues(fieldsRef, cloneObject(shallowFieldsStateRef.current), shouldUnregister, false, fieldNames);\n\n    if (isString(fieldNames)) {\n      const parentNodeName = getFieldArrayParentName(fieldNames) || fieldNames;\n\n      if (fieldArrayNamesRef.current.has(parentNodeName)) {\n        fieldValues = Object.assign(Object.assign({}, fieldArrayValuesRef.current), fieldValues);\n      }\n\n      return assignWatchFields(fieldValues, fieldNames, watchFields, isUndefined(get(defaultValuesRef.current, fieldNames)) ? defaultValue : get(defaultValuesRef.current, fieldNames), true);\n    }\n\n    const combinedDefaultValues = isUndefined(defaultValue) ? defaultValuesRef.current : defaultValue;\n\n    if (Array.isArray(fieldNames)) {\n      return fieldNames.reduce((previous, name) => Object.assign(Object.assign({}, previous), {\n        [name]: assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues)\n      }), {});\n    }\n\n    isWatchAllRef.current = isUndefined(watchId);\n    return transformToNestObject(!isEmptyObject(fieldValues) && fieldValues || combinedDefaultValues);\n  }, []);\n\n  function watch(fieldNames, defaultValue) {\n    return watchInternal(fieldNames, defaultValue);\n  }\n\n  function unregister(name) {\n    for (const fieldName of Array.isArray(name) ? name : [name]) {\n      removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true);\n    }\n  }\n\n  function registerFieldRef(ref) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!ref.name) {\n        return console.warn('📋 Field is missing `name` attribute', ref, `https://react-hook-form.com/api#useForm`);\n      }\n\n      if (fieldArrayNamesRef.current.has(ref.name.split(/\\[\\d+\\]$/)[0]) && !RegExp(`^${ref.name.split(/\\[\\d+\\]$/)[0]}[\\\\d+].\\\\w+`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]')).test(ref.name)) {\n        return console.warn('📋 `name` prop should be in object shape: name=\"test[index].name\"', ref, 'https://react-hook-form.com/api#useFieldArray');\n      }\n    }\n\n    const {\n      name,\n      type,\n      value\n    } = ref;\n    const fieldRefAndValidationOptions = Object.assign({\n      ref\n    }, options);\n    const fields = fieldsRef.current;\n    const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\n    const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n\n    const compareRef = currentRef => isWeb && (!isHTMLElement(ref) || currentRef === ref);\n\n    let field = fields[name];\n    let isEmptyDefaultValue = true;\n    let defaultValue;\n\n    if (field && (isRadioOrCheckbox ? Array.isArray(field.options) && compact(field.options).find(option => {\n      return value === option.ref.value && compareRef(option.ref);\n    }) : compareRef(field.ref))) {\n      fields[name] = Object.assign(Object.assign({}, field), options);\n      return;\n    }\n\n    if (type) {\n      field = isRadioOrCheckbox ? Object.assign({\n        options: [...compact(field && field.options || []), {\n          ref\n        }],\n        ref: {\n          type,\n          name\n        }\n      }, options) : Object.assign({}, fieldRefAndValidationOptions);\n    } else {\n      field = fieldRefAndValidationOptions;\n    }\n\n    fields[name] = field;\n    const isEmptyUnmountFields = isUndefined(get(shallowFieldsStateRef.current, name));\n\n    if (!isEmptyObject(defaultValuesRef.current) || !isEmptyUnmountFields) {\n      defaultValue = get(isEmptyUnmountFields ? defaultValuesRef.current : shallowFieldsStateRef.current, name);\n      isEmptyDefaultValue = isUndefined(defaultValue);\n\n      if (!isEmptyDefaultValue && !isFieldArray) {\n        setFieldValue(name, defaultValue);\n      }\n    }\n\n    if (!isEmptyObject(options)) {\n      set(fieldsWithValidationRef.current, name, true);\n\n      if (!isOnSubmit && readFormStateRef.current.isValid) {\n        validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef).then(error => {\n          const previousFormIsValid = formStateRef.current.isValid;\n          isEmptyObject(error) ? set(validFieldsRef.current, name, true) : unset(validFieldsRef.current, name);\n          previousFormIsValid !== isEmptyObject(error) && updateFormState();\n        });\n      }\n    }\n\n    if (shouldUnregister && !(isFieldArray && isEmptyDefaultValue)) {\n      !isFieldArray && unset(formStateRef.current.dirtyFields, name);\n    }\n\n    if (type) {\n      attachEventListeners(isRadioOrCheckbox && field.options ? field.options[field.options.length - 1] : field, isRadioOrCheckbox || isSelectInput(ref), handleChangeRef.current);\n    }\n  }\n\n  function register(refOrRegisterOptions, options) {\n    if (!isWindowUndefined) {\n      if (isString(refOrRegisterOptions)) {\n        registerFieldRef({\n          name: refOrRegisterOptions\n        }, options);\n      } else if (isObject(refOrRegisterOptions) && 'name' in refOrRegisterOptions) {\n        registerFieldRef(refOrRegisterOptions, options);\n      } else {\n        return ref => ref && registerFieldRef(ref, refOrRegisterOptions);\n      }\n    }\n  }\n\n  const handleSubmit = useCallback((onValid, onInvalid) => async e => {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n      e.persist();\n    }\n\n    let fieldErrors = {};\n    let fieldValues = setFieldArrayDefaultValues(getFieldsValues(fieldsRef, cloneObject(shallowFieldsStateRef.current), shouldUnregister, true));\n    readFormStateRef.current.isSubmitting && updateFormState({\n      isSubmitting: true\n    });\n\n    try {\n      if (resolverRef.current) {\n        const {\n          errors,\n          values\n        } = await resolverRef.current(fieldValues, contextRef.current, isValidateAllFieldCriteria);\n        formStateRef.current.errors = fieldErrors = errors;\n        fieldValues = values;\n      } else {\n        for (const field of Object.values(fieldsRef.current)) {\n          if (field) {\n            const {\n              name\n            } = field.ref;\n            const fieldError = await validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef);\n\n            if (fieldError[name]) {\n              set(fieldErrors, name, fieldError[name]);\n              unset(validFieldsRef.current, name);\n            } else if (get(fieldsWithValidationRef.current, name)) {\n              unset(formStateRef.current.errors, name);\n              set(validFieldsRef.current, name, true);\n            }\n          }\n        }\n      }\n\n      if (isEmptyObject(fieldErrors) && Object.keys(formStateRef.current.errors).every(name => name in fieldsRef.current)) {\n        updateFormState({\n          errors: {},\n          isSubmitting: true\n        });\n        await onValid(fieldValues, e);\n      } else {\n        formStateRef.current.errors = Object.assign(Object.assign({}, formStateRef.current.errors), fieldErrors);\n        onInvalid && (await onInvalid(formStateRef.current.errors, e));\n        shouldFocusError && focusOnErrorField(fieldsRef.current, formStateRef.current.errors);\n      }\n    } finally {\n      formStateRef.current.isSubmitting = false;\n      updateFormState({\n        isSubmitted: true,\n        isSubmitting: false,\n        isSubmitSuccessful: isEmptyObject(formStateRef.current.errors),\n        submitCount: formStateRef.current.submitCount + 1\n      });\n    }\n  }, [shouldFocusError, isValidateAllFieldCriteria]);\n\n  const resetRefs = _ref12 => {\n    let {\n      errors,\n      isDirty,\n      isSubmitted,\n      touched,\n      isValid,\n      submitCount,\n      dirtyFields\n    } = _ref12;\n\n    if (!isValid) {\n      validFieldsRef.current = {};\n      fieldsWithValidationRef.current = {};\n    }\n\n    fieldArrayDefaultValuesRef.current = {};\n    watchFieldsRef.current = new Set();\n    isWatchAllRef.current = false;\n    updateFormState({\n      submitCount: submitCount ? formStateRef.current.submitCount : 0,\n      isDirty: isDirty ? formStateRef.current.isDirty : false,\n      isSubmitted: isSubmitted ? formStateRef.current.isSubmitted : false,\n      isValid: isValid ? formStateRef.current.isValid : false,\n      dirtyFields: dirtyFields ? formStateRef.current.dirtyFields : {},\n      touched: touched ? formStateRef.current.touched : {},\n      errors: errors ? formStateRef.current.errors : {},\n      isSubmitting: false,\n      isSubmitSuccessful: false\n    });\n  };\n\n  const reset = function (values) {\n    let omitResetState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (isWeb) {\n      for (const field of Object.values(fieldsRef.current)) {\n        if (field) {\n          const {\n            ref,\n            options\n          } = field;\n          const inputRef = isRadioOrCheckboxFunction(ref) && Array.isArray(options) ? options[0].ref : ref;\n\n          if (isHTMLElement(inputRef)) {\n            try {\n              inputRef.closest('form').reset();\n              break;\n            } catch (_a) {}\n          }\n        }\n      }\n    }\n\n    fieldsRef.current = {};\n    defaultValuesRef.current = Object.assign({}, values || defaultValuesRef.current);\n    values && renderWatchedInputs('');\n    Object.values(resetFieldArrayFunctionRef.current).forEach(resetFieldArray => isFunction(resetFieldArray) && resetFieldArray());\n    shallowFieldsStateRef.current = shouldUnregister ? {} : cloneObject(values || defaultValuesRef.current);\n    resetRefs(omitResetState);\n  };\n\n  useEffect(() => {\n    resolver && readFormStateRef.current.isValid && validateResolver();\n    observerRef.current = observerRef.current || !isWeb ? observerRef.current : onDomRemove(fieldsRef, removeFieldEventListenerAndRef);\n  }, [removeFieldEventListenerAndRef, defaultValuesRef.current]);\n  useEffect(() => () => {\n    observerRef.current && observerRef.current.disconnect();\n    isUnMount.current = true;\n\n    if (process.env.NODE_ENV !== 'production') {\n      return;\n    }\n\n    Object.values(fieldsRef.current).forEach(field => removeFieldEventListenerAndRef(field, true));\n  }, []);\n\n  if (!resolver && readFormStateRef.current.isValid) {\n    formState.isValid = deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) && isEmptyObject(formStateRef.current.errors);\n  }\n\n  const commonProps = {\n    trigger,\n    setValue: useCallback(setValue, [setInternalValue, trigger]),\n    getValues: useCallback(getValues, []),\n    register: useCallback(register, [defaultValuesRef.current]),\n    unregister: useCallback(unregister, []),\n    formState: isProxyEnabled ? new Proxy(formState, {\n      get: (obj, prop) => {\n        if (process.env.NODE_ENV !== 'production') {\n          if (prop === 'isValid' && isOnSubmit) {\n            console.warn('📋 `formState.isValid` is applicable with `onTouched`, `onChange` or `onBlur` mode. https://react-hook-form.com/api#formState');\n          }\n        }\n\n        if (prop in obj) {\n          readFormStateRef.current[prop] = true;\n          return obj[prop];\n        }\n\n        return undefined;\n      }\n    }) : formState\n  };\n  const control = useMemo(() => Object.assign({\n    isFormDirty,\n    updateWatchedValue,\n    shouldUnregister,\n    updateFormState,\n    removeFieldEventListener,\n    watchInternal,\n    mode: modeRef.current,\n    reValidateMode: {\n      isReValidateOnBlur,\n      isReValidateOnChange\n    },\n    validateResolver: resolver ? validateResolver : undefined,\n    fieldsRef,\n    resetFieldArrayFunctionRef,\n    useWatchFieldsRef,\n    useWatchRenderFunctionsRef,\n    fieldArrayDefaultValuesRef,\n    validFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayNamesRef,\n    readFormStateRef,\n    formStateRef,\n    defaultValuesRef,\n    shallowFieldsStateRef,\n    fieldArrayValuesRef\n  }, commonProps), [defaultValuesRef.current, updateWatchedValue, shouldUnregister, removeFieldEventListener, watchInternal]);\n  return Object.assign({\n    watch,\n    control,\n    handleSubmit,\n    reset: useCallback(reset, []),\n    clearErrors: useCallback(clearErrors, []),\n    setError: useCallback(setError, []),\n    errors: formState.errors\n  }, commonProps);\n}\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nconst FormContext = createContext(null);\nFormContext.displayName = 'RHFContext';\n\nconst useFormContext = () => useContext(FormContext);\n\nconst FormProvider = _a => {\n  var {\n    children\n  } = _a,\n      props = __rest(_a, [\"children\"]);\n\n  return createElement(FormContext.Provider, {\n    value: Object.assign({}, props)\n  }, children);\n};\n\nvar generateId = () => {\n  const d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    const r = (Math.random() * 16 + d) % 16 | 0;\n    return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n  });\n};\n\nfunction removeAtIndexes(data, indexes) {\n  let i = 0;\n  const temp = [...data];\n\n  for (const index of indexes) {\n    temp.splice(index - i, 1);\n    i++;\n  }\n\n  return compact(temp).length ? temp : [];\n}\n\nvar removeArrayAt = (data, index) => isUndefined(index) ? [] : removeAtIndexes(data, (Array.isArray(index) ? index : [index]).sort((a, b) => a - b));\n\nvar moveArrayAt = (data, from, to) => {\n  if (Array.isArray(data)) {\n    if (isUndefined(data[to])) {\n      data[to] = undefined;\n    }\n\n    data.splice(to, 0, data.splice(from, 1)[0]);\n    return data;\n  }\n\n  return [];\n};\n\nvar swapArrayAt = (data, indexA, indexB) => {\n  const temp = [data[indexB], data[indexA]];\n  data[indexA] = temp[0];\n  data[indexB] = temp[1];\n};\n\nfunction prepend(data, value) {\n  return [...(Array.isArray(value) ? value : [value || undefined]), ...data];\n}\n\nfunction insert(data, index, value) {\n  return [...data.slice(0, index), ...(Array.isArray(value) ? value : [value || undefined]), ...data.slice(index)];\n}\n\nvar fillEmptyArray = value => Array.isArray(value) ? Array(value.length).fill(undefined) : undefined;\n\nvar fillBooleanArray = value => (Array.isArray(value) ? value : [value]).map(data => {\n  if (isObject(data)) {\n    const object = {};\n\n    for (const key in data) {\n      object[key] = true;\n    }\n\n    return object;\n  }\n\n  return true;\n});\n\nconst mapIds = function () {\n  let values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let keyName = arguments.length > 1 ? arguments[1] : undefined;\n  let skipWarn = arguments.length > 2 ? arguments[2] : undefined;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!skipWarn) {\n      for (const value of values) {\n        if (typeof value === 'object') {\n          if (keyName in value) {\n            console.warn(`📋 useFieldArray fieldValues contain the keyName \\`${keyName}\\` which is reserved for use by useFieldArray. https://react-hook-form.com/api#useFieldArray`);\n            break;\n          }\n        } else {\n          console.warn(`📋 useFieldArray input's name should be in object shape instead of flat array. https://react-hook-form.com/api#useFieldArray`);\n          break;\n        }\n      }\n    }\n  }\n\n  return values.map(value => Object.assign({\n    [keyName]: value[keyName] || generateId()\n  }, value));\n};\n\nconst useFieldArray = _ref13 => {\n  let {\n    control,\n    name,\n    keyName = 'id'\n  } = _ref13;\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error('📋 useFieldArray is missing `control` prop. https://react-hook-form.com/api#useFieldArray');\n    }\n  }\n\n  const focusIndexRef = useRef(-1);\n  const isUnMount = useRef(false);\n  const {\n    isFormDirty,\n    updateWatchedValue,\n    resetFieldArrayFunctionRef,\n    fieldArrayNamesRef,\n    fieldsRef,\n    defaultValuesRef,\n    removeFieldEventListener,\n    formStateRef,\n    shallowFieldsStateRef,\n    updateFormState,\n    readFormStateRef,\n    validFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayDefaultValuesRef,\n    validateResolver,\n    getValues,\n    shouldUnregister,\n    fieldArrayValuesRef\n  } = control || methods.control;\n\n  const getDefaultValues = values => get(shouldUnregister ? values : shallowFieldsStateRef.current, name, []);\n\n  const fieldArrayParentName = getFieldArrayParentName(name);\n  const memoizedDefaultValues = useRef([...(get(fieldArrayDefaultValuesRef.current, fieldArrayParentName) ? getDefaultValues(fieldArrayDefaultValuesRef.current) : getDefaultValues(defaultValuesRef.current))]);\n  const [fields, setFields] = useState(mapIds(memoizedDefaultValues.current, keyName));\n  set(fieldArrayValuesRef.current, name, compact(fields));\n\n  const omitKey = fields => fields.map(function () {\n    let _a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _b = keyName,\n        omitted = _a[_b],\n        rest = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n\n    return rest;\n  });\n\n  fieldArrayNamesRef.current.add(name);\n  const getFieldArrayValue = useCallback(() => get(fieldArrayValuesRef.current, name, []), [name]);\n\n  const getCurrentFieldsValues = () => mapIds(get(getValues(), name, getFieldArrayValue()).map((item, index) => Object.assign(Object.assign({}, getFieldArrayValue()[index]), item)), keyName, true);\n\n  fieldArrayNamesRef.current.add(name);\n\n  if (fieldArrayParentName && !get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)) {\n    set(fieldArrayDefaultValuesRef.current, fieldArrayParentName, cloneObject(get(defaultValuesRef.current, fieldArrayParentName)));\n  }\n\n  const setFieldAndValidState = fieldsValues => {\n    setFields(fieldsValues);\n    set(fieldArrayValuesRef.current, name, fieldsValues);\n\n    if (readFormStateRef.current.isValid && validateResolver) {\n      const values = getValues();\n      set(values, name, fieldsValues);\n      validateResolver(values);\n    }\n  };\n\n  const resetFields = () => {\n    for (const key in fieldsRef.current) {\n      if (isMatchFieldArrayName(key, name)) {\n        removeFieldEventListener(fieldsRef.current[key], true);\n        delete fieldsRef.current[key];\n      }\n    }\n  };\n\n  const cleanup = ref => !compact(get(ref, name, [])).length && unset(ref, name);\n\n  const updateDirtyFieldsWithDefaultValues = updatedFieldArrayValues => {\n    if (updatedFieldArrayValues) {\n      set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\n    }\n  };\n\n  const batchStateUpdate = function (method, args, updatedFieldValues) {\n    let updatedFormValues = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    let shouldSet = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    let shouldUpdateValid = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n    if (get(shallowFieldsStateRef.current, name)) {\n      const output = method(get(shallowFieldsStateRef.current, name), args.argA, args.argB);\n      shouldSet && set(shallowFieldsStateRef.current, name, output);\n    }\n\n    if (get(fieldArrayDefaultValuesRef.current, name)) {\n      const output = method(get(fieldArrayDefaultValuesRef.current, name), args.argA, args.argB);\n      shouldSet && set(fieldArrayDefaultValuesRef.current, name, output);\n    }\n\n    if (Array.isArray(get(formStateRef.current.errors, name))) {\n      const output = method(get(formStateRef.current.errors, name), args.argA, args.argB);\n      shouldSet && set(formStateRef.current.errors, name, output);\n      cleanup(formStateRef.current.errors);\n    }\n\n    if (readFormStateRef.current.touched && get(formStateRef.current.touched, name)) {\n      const output = method(get(formStateRef.current.touched, name), args.argA, args.argB);\n      shouldSet && set(formStateRef.current.touched, name, output);\n      cleanup(formStateRef.current.touched);\n    }\n\n    if (readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) {\n      set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFormValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\n      updateDirtyFieldsWithDefaultValues(updatedFieldValues);\n      cleanup(formStateRef.current.dirtyFields);\n    }\n\n    if (shouldUpdateValid && readFormStateRef.current.isValid && !validateResolver) {\n      set(validFieldsRef.current, name, method(get(validFieldsRef.current, name, []), args.argA));\n      cleanup(validFieldsRef.current);\n      set(fieldsWithValidationRef.current, name, method(get(fieldsWithValidationRef.current, name, []), args.argA));\n      cleanup(fieldsWithValidationRef.current);\n    }\n\n    if (!isUnMount.current && readFormStateRef.current.isDirty) {\n      updateFormState({\n        isDirty: isFormDirty(name, omitKey(updatedFormValues))\n      });\n    }\n  };\n\n  const append = function (value) {\n    let shouldFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const appendValue = Array.isArray(value) ? value : [value];\n    const updateFormValues = [...getCurrentFieldsValues(), ...mapIds(appendValue, keyName)];\n    setFieldAndValidState(updateFormValues);\n\n    if (readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) {\n      updateDirtyFieldsWithDefaultValues(updateFormValues);\n      updateFormState({\n        isDirty: true,\n        dirtyFields: formStateRef.current.dirtyFields\n      });\n    }\n\n    !shouldUnregister && set(shallowFieldsStateRef.current, name, [...(get(shallowFieldsStateRef.current, name) || []), ...cloneObject(appendValue)]);\n    focusIndexRef.current = shouldFocus ? get(fieldArrayValuesRef.current, name).length - 1 : -1;\n  };\n\n  const prepend$1 = function (value) {\n    let shouldFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const emptyArray = fillEmptyArray(value);\n    const updatedFieldArrayValues = prepend(getCurrentFieldsValues(), mapIds(Array.isArray(value) ? value : [value], keyName));\n    setFieldAndValidState(updatedFieldArrayValues);\n    resetFields();\n    batchStateUpdate(prepend, {\n      argA: emptyArray,\n      argC: fillBooleanArray(value)\n    }, updatedFieldArrayValues);\n    focusIndexRef.current = shouldFocus ? 0 : -1;\n  };\n\n  const remove = index => {\n    const fieldValues = getCurrentFieldsValues();\n    const updatedFieldValues = removeArrayAt(fieldValues, index);\n    setFieldAndValidState(updatedFieldValues);\n    resetFields();\n    batchStateUpdate(removeArrayAt, {\n      argA: index,\n      argC: index\n    }, updatedFieldValues, removeArrayAt(fieldValues, index), true, true);\n  };\n\n  const insert$1 = function (index, value) {\n    let shouldFocus = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    const emptyArray = fillEmptyArray(value);\n    const fieldValues = getCurrentFieldsValues();\n    const updatedFieldArrayValues = insert(fieldValues, index, mapIds(Array.isArray(value) ? value : [value], keyName));\n    setFieldAndValidState(updatedFieldArrayValues);\n    resetFields();\n    batchStateUpdate(insert, {\n      argA: index,\n      argB: emptyArray,\n      argC: index,\n      argD: fillBooleanArray(value)\n    }, updatedFieldArrayValues, insert(fieldValues, index));\n    focusIndexRef.current = shouldFocus ? index : -1;\n  };\n\n  const swap = (indexA, indexB) => {\n    const fieldValues = getCurrentFieldsValues();\n    swapArrayAt(fieldValues, indexA, indexB);\n    resetFields();\n    setFieldAndValidState([...fieldValues]);\n    batchStateUpdate(swapArrayAt, {\n      argA: indexA,\n      argB: indexB,\n      argC: indexA,\n      argD: indexB\n    }, undefined, fieldValues, false);\n  };\n\n  const move = (from, to) => {\n    const fieldValues = getCurrentFieldsValues();\n    moveArrayAt(fieldValues, from, to);\n    resetFields();\n    setFieldAndValidState([...fieldValues]);\n    batchStateUpdate(moveArrayAt, {\n      argA: from,\n      argB: to,\n      argC: from,\n      argD: to\n    }, undefined, fieldValues, false);\n  };\n\n  useEffect(() => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!name) {\n        console.warn('📋 useFieldArray is missing `name` attribute. https://react-hook-form.com/api#useFieldArray');\n      }\n    }\n\n    const defaultValues = get(fieldArrayDefaultValuesRef.current, name);\n\n    if (defaultValues && fields.length < defaultValues.length) {\n      set(fieldArrayDefaultValuesRef.current, name, defaultValues.slice(1));\n    }\n\n    updateWatchedValue(name);\n\n    if (focusIndexRef.current > -1) {\n      for (const key in fieldsRef.current) {\n        const field = fieldsRef.current[key];\n\n        if (key.startsWith(`${name}[${focusIndexRef.current}]`) && field.ref.focus) {\n          field.ref.focus();\n          break;\n        }\n      }\n    }\n\n    focusIndexRef.current = -1;\n  }, [fields, name]);\n  useEffect(() => {\n    const resetFunctions = resetFieldArrayFunctionRef.current;\n    const fieldArrayNames = fieldArrayNamesRef.current;\n\n    if (!getFieldArrayParentName(name)) {\n      resetFunctions[name] = data => {\n        resetFields();\n        !data && unset(fieldArrayDefaultValuesRef.current, name);\n        unset(shallowFieldsStateRef.current, name);\n        memoizedDefaultValues.current = get(data || defaultValuesRef.current, name);\n\n        if (!isUnMount.current) {\n          setFields(mapIds(memoizedDefaultValues.current, keyName));\n        }\n      };\n    }\n\n    return () => {\n      isUnMount.current = true;\n      shouldUnregister && remove();\n      resetFields();\n      delete resetFunctions[name];\n      unset(fieldArrayValuesRef.current, name);\n      fieldArrayNames.delete(name);\n    };\n  }, []);\n  return {\n    swap: useCallback(swap, [name]),\n    move: useCallback(move, [name]),\n    prepend: useCallback(prepend$1, [name]),\n    append: useCallback(append, [name]),\n    remove: useCallback(remove, [name]),\n    insert: useCallback(insert$1, [name]),\n    fields: compact(fields)\n  };\n};\n\nvar getInputValue = event => isPrimitive(event) || !isObject(event.target) || isObject(event.target) && !event.type ? event : isUndefined(event.target.value) ? event.target.checked : event.target.value;\n\nfunction useController(_ref14) {\n  let {\n    name,\n    rules,\n    defaultValue,\n    control,\n    onFocus\n  } = _ref14;\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error('📋 Controller is missing `control` prop. https://react-hook-form.com/api#Controller');\n    }\n  }\n\n  const {\n    defaultValuesRef,\n    setValue,\n    register,\n    unregister,\n    trigger,\n    mode,\n    reValidateMode: {\n      isReValidateOnBlur,\n      isReValidateOnChange\n    },\n    formState,\n    formStateRef: {\n      current: {\n        isSubmitted,\n        touched,\n        errors\n      }\n    },\n    updateFormState,\n    readFormStateRef,\n    fieldsRef,\n    fieldArrayNamesRef,\n    shallowFieldsStateRef\n  } = control || methods.control;\n  const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\n\n  const getInitialValue = () => !isUndefined(get(shallowFieldsStateRef.current, name)) && isNotFieldArray ? get(shallowFieldsStateRef.current, name) : isUndefined(defaultValue) ? get(defaultValuesRef.current, name) : defaultValue;\n\n  const [value, setInputStateValue] = useState(getInitialValue());\n  const valueRef = useRef(value);\n  const ref = useRef({\n    focus: () => null\n  });\n  const onFocusRef = useRef(onFocus || (() => {\n    if (isFunction(ref.current.focus)) {\n      ref.current.focus();\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!isFunction(ref.current.focus)) {\n        console.warn(`📋 'ref' from Controller render prop must be attached to a React component or a DOM Element whose ref provides a 'focus()' method`);\n      }\n    }\n  }));\n  const shouldValidate = useCallback(isBlurEvent => !skipValidation(Object.assign({\n    isBlurEvent,\n    isReValidateOnBlur,\n    isReValidateOnChange,\n    isSubmitted,\n    isTouched: !!get(touched, name)\n  }, mode)), [isReValidateOnBlur, isReValidateOnChange, isSubmitted, touched, name, mode]);\n  const commonTask = useCallback(_ref15 => {\n    let [event] = _ref15;\n    const data = getInputValue(event);\n    setInputStateValue(data);\n    valueRef.current = data;\n    return data;\n  }, []);\n  const registerField = useCallback(shouldUpdateValue => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!name) {\n        return console.warn('📋 Field is missing `name` prop. https://react-hook-form.com/api#Controller');\n      }\n    }\n\n    if (fieldsRef.current[name]) {\n      fieldsRef.current[name] = Object.assign({\n        ref: fieldsRef.current[name].ref\n      }, rules);\n    } else {\n      register(Object.defineProperties({\n        name,\n        focus: onFocusRef.current\n      }, {\n        value: {\n          set(data) {\n            setInputStateValue(data);\n            valueRef.current = data;\n          },\n\n          get() {\n            return valueRef.current;\n          }\n\n        }\n      }), rules);\n      shouldUpdateValue = isUndefined(get(defaultValuesRef.current, name));\n    }\n\n    shouldUpdateValue && isNotFieldArray && setInputStateValue(getInitialValue());\n  }, [rules, name, register]);\n  useEffect(() => () => unregister(name), [name]);\n  useEffect(() => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (isUndefined(value)) {\n        console.warn(`📋 ${name} is missing in the 'defaultValue' prop of either its Controller (https://react-hook-form.com/api#Controller) or useForm (https://react-hook-form.com/api#useForm)`);\n      }\n\n      if (!isNotFieldArray && isUndefined(defaultValue)) {\n        console.warn('📋 Controller is missing `defaultValue` prop when using `useFieldArray`. https://react-hook-form.com/api#Controller');\n      }\n    }\n\n    registerField();\n  }, [registerField]);\n  useEffect(() => {\n    !fieldsRef.current[name] && registerField(true);\n  });\n  const onBlur = useCallback(() => {\n    if (readFormStateRef.current.touched && !get(touched, name)) {\n      set(touched, name, true);\n      updateFormState({\n        touched\n      });\n    }\n\n    shouldValidate(true) && trigger(name);\n  }, [name, updateFormState, shouldValidate, trigger, readFormStateRef]);\n  const onChange = useCallback(function () {\n    for (var _len = arguments.length, event = new Array(_len), _key = 0; _key < _len; _key++) {\n      event[_key] = arguments[_key];\n    }\n\n    return setValue(name, commonTask(event), {\n      shouldValidate: shouldValidate(),\n      shouldDirty: true\n    });\n  }, [setValue, name, shouldValidate]);\n  return {\n    field: {\n      onChange,\n      onBlur,\n      name,\n      value,\n      ref\n    },\n    meta: Object.defineProperties({\n      invalid: !!get(errors, name)\n    }, {\n      isDirty: {\n        get() {\n          return !!get(formState.dirtyFields, name);\n        }\n\n      },\n      isTouched: {\n        get() {\n          return !!get(formState.touched, name);\n        }\n\n      }\n    })\n  };\n}\n\nfunction useWatch(_ref16) {\n  let {\n    control,\n    name,\n    defaultValue\n  } = _ref16;\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error('📋 useWatch is missing `control` prop. https://react-hook-form.com/api#useWatch');\n    }\n  }\n\n  const {\n    useWatchFieldsRef,\n    useWatchRenderFunctionsRef,\n    watchInternal,\n    defaultValuesRef\n  } = control || methods.control;\n  const updateValue = useState()[1];\n  const idRef = useRef();\n  const defaultValueRef = useRef(defaultValue);\n  useEffect(() => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (name === '') {\n        console.warn('📋 useWatch is missing `name` attribute. https://react-hook-form.com/api#useWatch');\n      }\n    }\n\n    const id = idRef.current = generateId();\n    const watchFieldsHookRender = useWatchRenderFunctionsRef.current;\n    const watchFieldsHook = useWatchFieldsRef.current;\n    watchFieldsHook[id] = new Set();\n\n    watchFieldsHookRender[id] = () => updateValue({});\n\n    watchInternal(name, defaultValueRef.current, id);\n    return () => {\n      delete watchFieldsHook[id];\n      delete watchFieldsHookRender[id];\n    };\n  }, [name, useWatchRenderFunctionsRef, useWatchFieldsRef, watchInternal, defaultValueRef]);\n  return idRef.current ? watchInternal(name, defaultValueRef.current, idRef.current) : isUndefined(defaultValue) ? isString(name) ? get(defaultValuesRef.current, name) : Array.isArray(name) ? name.reduce((previous, inputName) => Object.assign(Object.assign({}, previous), {\n    [inputName]: get(defaultValuesRef.current, inputName)\n  }), {}) : defaultValuesRef.current : defaultValue;\n}\n\nconst Controller = props => {\n  const {\n    rules,\n    as,\n    render,\n    defaultValue,\n    control,\n    onFocus\n  } = props,\n        rest = __rest(props, [\"rules\", \"as\", \"render\", \"defaultValue\", \"control\", \"onFocus\"]);\n\n  const {\n    field,\n    meta\n  } = useController(props);\n  const componentProps = Object.assign(Object.assign({}, rest), field);\n  return as ? isValidElement(as) ? cloneElement(as, componentProps) : createElement(as, componentProps) : render ? render(field, meta) : null;\n};\n\nexport { Controller, FormProvider, appendErrors, get, transformToNestObject, useController, useFieldArray, useForm, useFormContext, useWatch };","map":{"version":3,"mappings":"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","names":["value","HTMLElement","EVENTS","BLUR","CHANGE","INPUT","VALIDATION_MODE","onBlur","onChange","onSubmit","onTouched","all","SELECT","UNDEFINED","INPUT_VALIDATION_RULES","max","min","maxLength","minLength","pattern","required","validate","attachEventListeners","shouldAttachChangeEvent","handleChange","ref","isHTMLElement","addEventListener","isObjectType","isNullOrUndefined","Array","isArray","Date","test","filter","Boolean","input","compact","replace","split","set","object","path","index","tempPath","isKey","stringToPath","length","lastIndex","key","newValue","objValue","isObject","isNaN","data","val","undefined","obj","defaultValue","result","reduce","isUndefined","fields","fieldErrors","get","field","focus","options","validateWithStateUpdate","removeEventListener","defaultReturn","isValid","previous","option","checked","selected","map","element","type","defaultResult","validResult","values","attributes","getFieldValue","fieldsRef","name","shallowFieldsStateRef","excludeDisabled","shouldKeepRawValue","current","disabled","valueAsNumber","valueAsDate","setValueAs","isFileInput","files","isRadioInput","getRadioValue","isMultipleSelect","getMultipleSelectValue","isCheckBox","getCheckboxValue","NaN","isDetached","nodeType","Node","DOCUMENT_NODE","parentNode","Object","keys","baseGet","updatePath","slice","unset","childObject","previousObjRef","k","objectRef","currentPaths","currentPathsLength","item","isEmptyObject","isBoolean","isSameRef","fieldValue","findRemovedFieldAndRemoveListener","shouldUnregister","forceDelete","fieldRef","isCheckBoxInput","forEach","removeAllEventListeners","deepMerge","target","source","isPrimitive","targetValue","sourceValue","deepEqual","object1","object2","isErrorObject","React.isValidElement","keys1","keys2","val1","val2","setDirtyFields","defaultValues","dirtyFields","parentName","shallowFieldsState","search","output","isString","startsWith","find","transformToNestObject","errors","error","validFields","fieldsWithValidation","previousError","RegExp","validationData","isRegex","message","getValidateError","isMessage","validateAllFieldCriteria","types","isRadio","isRadioOrCheckbox","isEmpty","appendErrorsCurry","appendErrors","bind","getMinMaxMessage","exceedMax","maxLengthMessage","minLengthMessage","maxType","minType","getValueAndMessage","exceedMin","maxOutput","minOutput","valueNumber","parseFloat","valueDate","maxLengthOutput","minLengthOutput","patternValue","getFieldsValue","validateRef","isFunction","validateError","validationResult","validateFunction","entries","validateResult","getPath","rootPath","paths","property","rootName","push","fieldValues","fieldName","watchFields","inputValue","isSingleField","add","isOnBlur","isOnChange","isOnTouch","isTouched","isReValidateOnBlur","isReValidateOnChange","isBlurEvent","isSubmitted","isOnAll","substring","indexOf","isMatchFieldArrayName","searchName","names","some","onDomRemove","removeFieldEventListenerAndRef","observer","MutationObserver","observe","window","document","childList","subtree","cloneObject","copy","isWeb","File","includes","constructor","_a","getTime","Set","Map","mode","isOnSubmit","isWindowUndefined","isProxyEnabled","Proxy","useForm","reValidateMode","resolver","context","shouldFocusError","criteriaMode","React.useRef","fieldArrayDefaultValuesRef","fieldArrayValuesRef","watchFieldsRef","useWatchFieldsRef","useWatchRenderFunctionsRef","fieldsWithValidationRef","validFieldsRef","defaultValuesRef","isUnMount","isWatchAllRef","handleChangeRef","resetFieldArrayFunctionRef","contextRef","resolverRef","fieldArrayNamesRef","modeRef","modeChecker","isValidateAllFieldCriteria","formState","setFormState","React.useState","isDirty","isValidating","submitCount","touched","isSubmitting","isSubmitSuccessful","readFormStateRef","formStateRef","observerRef","updateFormState","React.useCallback","state","updateIsValidating","shouldRenderBaseOnError","shouldRender","shouldReRender","isErrorStateChanged","setFieldValue","rawValue","radioRef","selectRef","checkboxRef","isFormDirty","formValues","getValues","updateAndGetDirtyState","isFieldDirty","isDirtyFieldExist","previousIsDirty","isChanged","executeValidation","skipReRender","process","env","NODE_ENV","console","warn","validateField","executeSchemaOrResolverValidation","previousFormIsValid","isInputsValid","every","trigger","Promise","setInternalValues","shouldDirty","shouldValidate","setInternalValue","config","has","getNodeParentName","setFieldArrayDirtyFields","isFieldWatched","match","renderWatchedInputs","found","size","setValue","shouldSkipValidation","skipValidation","parentNodeName","currentError","setFieldArrayDefaultValues","payload","getFieldsValues","validateResolver","newDefaultValues","removeFieldEventListener","updateWatchedValue","watchField","clearErrors","inputName","setError","shouldFocus","watchInternal","fieldNames","watchId","assignWatchFields","combinedDefaultValues","watch","unregister","registerFieldRef","fieldRefAndValidationOptions","isRadioOrCheckboxFunction","isFieldArray","isNameInFieldArray","compareRef","currentRef","isEmptyDefaultValue","isEmptyUnmountFields","then","isSelectInput","register","refOrRegisterOptions","handleSubmit","onValid","onInvalid","e","preventDefault","persist","fieldError","focusOnErrorField","resetRefs","reset","omitResetState","inputRef","closest","resetFieldArray","React.useEffect","disconnect","commonProps","prop","control","React.useMemo","FormContext","React.createContext","displayName","useFormContext","React.useContext","FormProvider","children","props","React.createElement","Provider","d","performance","now","c","r","Math","random","toString","removeAtIndexes","indexes","i","temp","splice","sort","a","b","from","to","indexA","indexB","prepend","insert","fill","mapIds","keyName","skipWarn","generateId","useFieldArray","methods","Error","focusIndexRef","getDefaultValues","fieldArrayParentName","getFieldArrayParentName","memoizedDefaultValues","setFields","omitKey","_b","omitted","rest","getFieldArrayValue","getCurrentFieldsValues","setFieldAndValidState","fieldsValues","resetFields","cleanup","updateDirtyFieldsWithDefaultValues","updatedFieldArrayValues","batchStateUpdate","method","args","updatedFieldValues","updatedFormValues","shouldSet","shouldUpdateValid","argA","argB","append","appendValue","updateFormValues","emptyArray","fillEmptyArray","prependAt","argC","fillBooleanArray","remove","removeArrayAt","insertAt","argD","swap","swapArrayAt","move","moveArrayAt","resetFunctions","fieldArrayNames","delete","event","useController","rules","onFocus","isNotFieldArray","getInitialValue","setInputStateValue","valueRef","onFocusRef","commonTask","getInputValue","registerField","shouldUpdateValue","defineProperties","meta","invalid","useWatch","updateValue","idRef","defaultValueRef","id","watchFieldsHookRender","watchFieldsHook","Controller","as","render","componentProps","React.cloneElement"],"sources":["C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\isHTMLElement.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\constants.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\logic\\attachEventListeners.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\isNullOrUndefined.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\isObject.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\isKey.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\compact.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\stringToPath.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\set.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\logic\\transformToNestObject.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\isUndefined.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\get.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\logic\\focusOnErrorField.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\logic\\removeAllEventListeners.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\logic\\getRadioValue.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\logic\\getMultipleSelectValue.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\isRadioInput.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\isFileInput.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\isCheckBoxInput.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\isMultipleSelect.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\logic\\getCheckboxValue.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\logic\\getFieldValue.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\isDetached.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\isEmptyObject.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\isBoolean.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\unset.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\logic\\findRemovedFieldAndRemoveListener.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\isPrimitive.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\deepMerge.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\deepEqual.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\logic\\setFieldArrayDirtyFields.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\isString.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\logic\\getFieldsValues.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\logic\\isErrorStateChanged.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\isRegex.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\logic\\getValueAndMessage.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\isFunction.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\isMessage.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\logic\\getValidateError.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\logic\\appendErrors.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\logic\\validateField.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\getPath.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\logic\\assignWatchFields.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\logic\\skipValidation.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\logic\\getNodeParentName.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\logic\\isNameInFieldArray.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\isSelectInput.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\onDomRemove.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\isWeb.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\cloneObject.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\validationModeChecker.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\isRadioOrCheckbox.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\useForm.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\useFormContext.tsx","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\logic\\generateId.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\remove.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\move.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\swap.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\prepend.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\insert.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\fillEmptyArray.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\utils\\fillBooleanArray.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\useFieldArray.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\logic\\getInputValue.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\useController.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\useWatch.ts","C:\\Users\\jayes\\Downloads\\react-hook-form-crud-example\\node_modules\\react-hook-form\\src\\controller.tsx"],"sourcesContent":["export default (value: any): value is HTMLElement =>\n  value instanceof HTMLElement;\n","import { ValidationMode } from './types';\n\nexport const EVENTS = {\n  BLUR: 'blur',\n  CHANGE: 'change',\n  INPUT: 'input',\n};\n\nexport const VALIDATION_MODE: ValidationMode = {\n  onBlur: 'onBlur',\n  onChange: 'onChange',\n  onSubmit: 'onSubmit',\n  onTouched: 'onTouched',\n  all: 'all',\n};\n\nexport const SELECT = 'select';\n\nexport const UNDEFINED = 'undefined';\n\nexport const INPUT_VALIDATION_RULES = {\n  max: 'max',\n  min: 'min',\n  maxLength: 'maxLength',\n  minLength: 'minLength',\n  pattern: 'pattern',\n  required: 'required',\n  validate: 'validate',\n};\n","import isHTMLElement from '../utils/isHTMLElement';\nimport { EVENTS } from '../constants';\nimport { Field } from '../types';\n\nexport default function attachEventListeners(\n  { ref }: Field,\n  shouldAttachChangeEvent?: boolean,\n  handleChange?: EventListenerOrEventListenerObject,\n): void {\n  if (isHTMLElement(ref) && handleChange) {\n    ref.addEventListener(\n      shouldAttachChangeEvent ? EVENTS.CHANGE : EVENTS.INPUT,\n      handleChange,\n    );\n    ref.addEventListener(EVENTS.BLUR, handleChange);\n  }\n}\n","export default (value: unknown): value is null | undefined => value == null;\n","import isNullOrUndefined from './isNullOrUndefined';\n\nexport const isObjectType = (value: unknown) => typeof value === 'object';\n\nexport default <T extends object>(value: unknown): value is T =>\n  !isNullOrUndefined(value) &&\n  !Array.isArray(value) &&\n  isObjectType(value) &&\n  !(value instanceof Date);\n","export default (value: string) => /^\\w*$/.test(value);\n","export default (value: any[]) => value.filter(Boolean);\n","import compact from './compact';\n\nexport default (input: string): string[] =>\n  compact(\n    input\n      .replace(/[\"|']/g, '')\n      .replace(/\\[/g, '.')\n      .replace(/\\]/g, '')\n      .split('.'),\n  );\n","import isObject from './isObject';\nimport isKey from './isKey';\nimport stringToPath from './stringToPath';\nimport { FieldValues } from '../types';\n\nexport default function set(\n  object: FieldValues,\n  path: string,\n  value?: unknown,\n) {\n  let index = -1;\n  const tempPath = isKey(path) ? [path] : stringToPath(path);\n  const length = tempPath.length;\n  const lastIndex = length - 1;\n\n  while (++index < length) {\n    const key = tempPath[index];\n    let newValue = value;\n\n    if (index !== lastIndex) {\n      const objValue = object[key];\n      newValue =\n        isObject(objValue) || Array.isArray(objValue)\n          ? objValue\n          : !isNaN(+tempPath[index + 1])\n          ? []\n          : {};\n    }\n    object[key] = newValue;\n    object = object[key];\n  }\n  return object;\n}\n","import set from '../utils/set';\nimport isKey from '../utils/isKey';\nimport { FieldValues } from '../types';\n\nexport default (data: FieldValues, value: Record<string, any> = {}): any => {\n  for (const key in data) {\n    !isKey(key) ? set(value, key, data[key]) : (value[key] = data[key]);\n  }\n  return value;\n};\n","export default (val: unknown): val is undefined => val === undefined;\n","import isUndefined from './isUndefined';\nimport isNullOrUndefined from './isNullOrUndefined';\nimport compact from './compact';\n\nexport default (obj: any = {}, path: string, defaultValue?: unknown) => {\n  const result = compact(path.split(/[,[\\].]+?/)).reduce(\n    (result, key) => (isNullOrUndefined(result) ? result : result[key]),\n    obj,\n  );\n\n  return isUndefined(result) || result === obj\n    ? isUndefined(obj[path])\n      ? defaultValue\n      : obj[path]\n    : result;\n};\n","import get from '../utils/get';\nimport isUndefined from '../utils/isUndefined';\nimport { FieldErrors, FieldRefs } from '../types';\n\nexport default <TFieldValues>(\n  fields: FieldRefs<TFieldValues>,\n  fieldErrors: FieldErrors<TFieldValues>,\n) => {\n  for (const key in fields) {\n    if (get(fieldErrors, key)) {\n      const field = fields[key];\n\n      if (field) {\n        if (field.ref.focus && isUndefined(field.ref.focus())) {\n          break;\n        } else if (field.options) {\n          field.options[0].ref.focus();\n\n          break;\n        }\n      }\n    }\n  }\n};\n","import isHTMLElement from '../utils/isHTMLElement';\nimport { EVENTS } from '../constants';\nimport { Ref } from '../types';\n\nexport default (\n  ref: Ref,\n  validateWithStateUpdate: EventListenerOrEventListenerObject,\n): void => {\n  if (isHTMLElement(ref) && ref.removeEventListener) {\n    ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\n  }\n};\n","import { RadioOrCheckboxOption } from '../types';\n\ntype RadioFieldResult = {\n  isValid: boolean;\n  value: number | string | null;\n};\n\nconst defaultReturn: RadioFieldResult = {\n  isValid: false,\n  value: null,\n};\n\nexport default (options?: RadioOrCheckboxOption[]): RadioFieldResult =>\n  Array.isArray(options)\n    ? options.reduce(\n        (previous, option): RadioFieldResult =>\n          option && option.ref.checked\n            ? {\n                isValid: true,\n                value: option.ref.value,\n              }\n            : previous,\n        defaultReturn,\n      )\n    : defaultReturn;\n","export default (\n  options: HTMLOptionElement[] | HTMLOptionsCollection,\n): string[] =>\n  [...options]\n    .filter(({ selected }): boolean => selected)\n    .map(({ value }): string => value);\n","import { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'radio';\n","import { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'file';\n","import { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'checkbox';\n","import { FieldElement } from '../types';\nimport { SELECT } from '../constants';\n\nexport default (element: FieldElement): element is HTMLSelectElement =>\n  element.type === `${SELECT}-multiple`;\n","import isUndefined from '../utils/isUndefined';\nimport { RadioOrCheckboxOption } from '../types';\n\ntype CheckboxFieldResult = {\n  isValid: boolean;\n  value: string | string[] | boolean;\n};\n\nconst defaultResult: CheckboxFieldResult = {\n  value: false,\n  isValid: false,\n};\n\nconst validResult = { value: true, isValid: true };\n\nexport default (options?: RadioOrCheckboxOption[]): CheckboxFieldResult => {\n  if (Array.isArray(options)) {\n    if (options.length > 1) {\n      const values = options\n        .filter((option) => option && option.ref.checked)\n        .map(({ ref: { value } }) => value);\n      return { value: values, isValid: !!values.length };\n    }\n\n    const { checked, value, attributes } = options[0].ref;\n\n    return checked\n      ? attributes && !isUndefined((attributes as any).value)\n        ? isUndefined(value) || value === ''\n          ? validResult\n          : { value: value, isValid: true }\n        : validResult\n      : defaultResult;\n  }\n\n  return defaultResult;\n};\n","import * as React from 'react';\nimport getRadioValue from './getRadioValue';\nimport getMultipleSelectValue from './getMultipleSelectValue';\nimport isRadioInput from '../utils/isRadioInput';\nimport get from '../utils/get';\nimport isFileInput from '../utils/isFileInput';\nimport isCheckBox from '../utils/isCheckBoxInput';\nimport isMultipleSelect from '../utils/isMultipleSelect';\nimport getCheckboxValue from './getCheckboxValue';\nimport { FieldRefs, FieldValues, InternalFieldName } from '../types';\n\nexport default function getFieldValue<TFieldValues extends FieldValues>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  name: InternalFieldName<TFieldValues>,\n  shallowFieldsStateRef?: React.MutableRefObject<Partial<FieldValues>>,\n  excludeDisabled?: boolean,\n  shouldKeepRawValue?: boolean,\n) {\n  const field = fieldsRef.current[name]!;\n\n  if (field) {\n    const {\n      ref: { value, disabled },\n      ref,\n      valueAsNumber,\n      valueAsDate,\n      setValueAs,\n    } = field;\n\n    if (disabled && excludeDisabled) {\n      return;\n    }\n\n    if (isFileInput(ref)) {\n      return ref.files;\n    }\n\n    if (isRadioInput(ref)) {\n      return getRadioValue(field.options).value;\n    }\n\n    if (isMultipleSelect(ref)) {\n      return getMultipleSelectValue(ref.options);\n    }\n\n    if (isCheckBox(ref)) {\n      return getCheckboxValue(field.options).value;\n    }\n\n    return shouldKeepRawValue\n      ? value\n      : valueAsNumber\n      ? value === ''\n        ? NaN\n        : +value\n      : valueAsDate\n      ? (ref as HTMLInputElement).valueAsDate\n      : setValueAs\n      ? setValueAs(value)\n      : value;\n  }\n\n  if (shallowFieldsStateRef) {\n    return get(shallowFieldsStateRef.current, name);\n  }\n}\n","import { Ref } from '../types';\n\nexport default function isDetached(element: Ref): boolean {\n  if (!element) {\n    return true;\n  }\n\n  if (\n    !(element instanceof HTMLElement) ||\n    element.nodeType === Node.DOCUMENT_NODE\n  ) {\n    return false;\n  }\n\n  return isDetached(element.parentNode as Ref);\n}\n","import isObject from './isObject';\nimport { EmptyObject } from '../types';\n\nexport default (value: unknown): value is EmptyObject =>\n  isObject(value) && !Object.keys(value).length;\n","export default (value: unknown): value is boolean => typeof value === 'boolean';\n","import isKey from './isKey';\nimport stringToPath from './stringToPath';\nimport isEmptyObject from './isEmptyObject';\nimport isObject from './isObject';\nimport isUndefined from './isUndefined';\nimport isBoolean from './isBoolean';\n\nfunction baseGet(object: any, updatePath: (string | number)[]) {\n  const length = updatePath.slice(0, -1).length;\n  let index = 0;\n\n  while (index < length) {\n    object = isUndefined(object) ? index++ : object[updatePath[index++]];\n  }\n\n  return object;\n}\n\nexport default function unset(object: any, path: string) {\n  const updatePath = isKey(path) ? [path] : stringToPath(path);\n  const childObject =\n    updatePath.length == 1 ? object : baseGet(object, updatePath);\n  const key = updatePath[updatePath.length - 1];\n  let previousObjRef;\n\n  if (childObject) {\n    delete childObject[key];\n  }\n\n  for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\n    let index = -1;\n    let objectRef;\n    const currentPaths = updatePath.slice(0, -(k + 1));\n    const currentPathsLength = currentPaths.length - 1;\n\n    if (k > 0) {\n      previousObjRef = object;\n    }\n\n    while (++index < currentPaths.length) {\n      const item = currentPaths[index];\n      objectRef = objectRef ? objectRef[item] : object[item];\n\n      if (\n        currentPathsLength === index &&\n        ((isObject(objectRef) && isEmptyObject(objectRef)) ||\n          (Array.isArray(objectRef) &&\n            !objectRef.filter(\n              (data) =>\n                (isObject(data) && !isEmptyObject(data)) || isBoolean(data),\n            ).length))\n      ) {\n        previousObjRef ? delete previousObjRef[item] : delete object[item];\n      }\n\n      previousObjRef = objectRef;\n    }\n  }\n\n  return object;\n}\n","import * as React from 'react';\nimport removeAllEventListeners from './removeAllEventListeners';\nimport getFieldValue from './getFieldValue';\nimport isRadioInput from '../utils/isRadioInput';\nimport set from '../utils/set';\nimport isCheckBoxInput from '../utils/isCheckBoxInput';\nimport isDetached from '../utils/isDetached';\nimport unset from '../utils/unset';\nimport compact from '../utils/compact';\nimport isUndefined from '../utils/isUndefined';\nimport { Field, FieldRefs, FieldValues, Ref } from '../types';\n\nconst isSameRef = (fieldValue: Field, ref: Ref) =>\n  fieldValue && fieldValue.ref === ref;\n\nexport default function findRemovedFieldAndRemoveListener<\n  TFieldValues extends FieldValues\n>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  handleChange: ({ type, target }: Event) => Promise<void | boolean>,\n  field: Field,\n  shallowFieldsStateRef: React.MutableRefObject<FieldValues>,\n  shouldUnregister?: boolean,\n  forceDelete?: boolean,\n): void {\n  const {\n    ref,\n    ref: { name },\n  } = field;\n  const fieldRef = fieldsRef.current[name] as Field;\n\n  if (!shouldUnregister) {\n    const value = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\n\n    !isUndefined(value) && set(shallowFieldsStateRef.current, name, value);\n  }\n\n  if (!ref.type || !fieldRef) {\n    delete fieldsRef.current[name];\n    return;\n  }\n\n  if (isRadioInput(ref) || isCheckBoxInput(ref)) {\n    if (Array.isArray(fieldRef.options) && fieldRef.options.length) {\n      compact(fieldRef.options).forEach((option = {}, index): void => {\n        if (\n          (isDetached(option.ref) && isSameRef(option, option.ref)) ||\n          forceDelete\n        ) {\n          removeAllEventListeners(option.ref, handleChange);\n          unset(fieldRef.options, `[${index}]`);\n        }\n      });\n\n      if (fieldRef.options && !compact(fieldRef.options).length) {\n        delete fieldsRef.current[name];\n      }\n    } else {\n      delete fieldsRef.current[name];\n    }\n  } else if ((isDetached(ref) && isSameRef(fieldRef, ref)) || forceDelete) {\n    removeAllEventListeners(ref, handleChange);\n\n    delete fieldsRef.current[name];\n  }\n}\n","import isNullOrUndefined from './isNullOrUndefined';\nimport { isObjectType } from './isObject';\nimport { Primitive } from '../types';\n\nexport default (value: unknown): value is Primitive =>\n  isNullOrUndefined(value) || !isObjectType(value);\n","import isObject from './isObject';\nimport isPrimitive from './isPrimitive';\n\nexport function deepMerge<\n  T extends Record<keyof T, any>,\n  U extends Record<keyof U, any>\n>(target: T, source: U): T & U {\n  if (isPrimitive(target) || isPrimitive(source)) {\n    return source;\n  }\n\n  for (const key in source) {\n    const targetValue = target[key];\n    const sourceValue = source[key];\n\n    try {\n      target[key] =\n        (isObject(targetValue) && isObject(sourceValue)) ||\n        (Array.isArray(targetValue) && Array.isArray(sourceValue))\n          ? deepMerge(targetValue, sourceValue)\n          : sourceValue;\n    } catch {}\n  }\n\n  return target;\n}\n","import * as React from 'react';\nimport isObject from '../utils/isObject';\nimport isPrimitive from './isPrimitive';\n\nexport default function deepEqual(\n  object1: any,\n  object2: any,\n  isErrorObject?: boolean,\n) {\n  if (\n    isPrimitive(object1) ||\n    isPrimitive(object2) ||\n    object1 instanceof Date ||\n    object2 instanceof Date\n  ) {\n    return object1 === object2;\n  }\n\n  if (!React.isValidElement(object1)) {\n    const keys1 = Object.keys(object1);\n    const keys2 = Object.keys(object2);\n\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n\n    for (const key of keys1) {\n      const val1 = object1[key];\n\n      if (!(isErrorObject && key === 'ref')) {\n        const val2 = object2[key];\n\n        if (\n          (isObject(val1) || Array.isArray(val1)) &&\n          (isObject(val2) || Array.isArray(val2))\n            ? !deepEqual(val1, val2, isErrorObject)\n            : val1 !== val2\n        ) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n","import { get } from '../utils';\nimport set from '../utils/set';\nimport { deepMerge } from '../utils/deepMerge';\nimport deepEqual from '../utils/deepEqual';\n\nfunction setDirtyFields<\n  T extends Record<string, unknown>[],\n  U extends Record<string, unknown>[],\n  K extends Record<string, boolean | []>\n>(\n  values: T,\n  defaultValues: U,\n  dirtyFields: Record<string, boolean | []>[],\n  parentNode?: K,\n  parentName?: keyof K,\n) {\n  let index = -1;\n\n  while (++index < values.length) {\n    for (const key in values[index]) {\n      if (Array.isArray(values[index][key])) {\n        !dirtyFields[index] && (dirtyFields[index] = {});\n        dirtyFields[index][key] = [];\n        setDirtyFields(\n          values[index][key] as T,\n          get(defaultValues[index] || {}, key, []),\n          dirtyFields[index][key] as [],\n          dirtyFields[index],\n          key,\n        );\n      } else {\n        deepEqual(get(defaultValues[index] || {}, key), values[index][key])\n          ? set(dirtyFields[index] || {}, key)\n          : (dirtyFields[index] = {\n              ...dirtyFields[index],\n              [key]: true,\n            });\n      }\n    }\n\n    parentNode &&\n      !dirtyFields.length &&\n      delete parentNode[parentName as keyof K];\n  }\n\n  return dirtyFields;\n}\n\nexport default <T extends U, U extends Record<string, unknown>[]>(\n  values: T,\n  defaultValues: U,\n  dirtyFields: Record<string, boolean | []>[],\n) =>\n  deepMerge(\n    setDirtyFields(values, defaultValues, dirtyFields.slice(0, values.length)),\n    setDirtyFields(defaultValues, values, dirtyFields.slice(0, values.length)),\n  );\n","export default (value: unknown): value is string => typeof value === 'string';\n","import * as React from 'react';\nimport getFieldValue from './getFieldValue';\nimport isString from '../utils/isString';\nimport { deepMerge } from '../utils/deepMerge';\nimport isUndefined from '../utils/isUndefined';\nimport { InternalFieldName, FieldValues, FieldRefs } from '../types';\nimport transformToNestObject from './transformToNestObject';\n\nexport default <TFieldValues extends FieldValues>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  shallowFieldsState: Record<string, any>,\n  shouldUnregister: boolean,\n  excludeDisabled?: boolean,\n  search?:\n    | InternalFieldName<TFieldValues>\n    | InternalFieldName<TFieldValues>[]\n    | { nest: boolean },\n) => {\n  const output = {} as TFieldValues;\n\n  for (const name in fieldsRef.current) {\n    if (\n      isUndefined(search) ||\n      (isString(search)\n        ? name.startsWith(search)\n        : Array.isArray(search) && search.find((data) => name.startsWith(data)))\n    ) {\n      output[name as InternalFieldName<TFieldValues>] = getFieldValue(\n        fieldsRef,\n        name,\n        undefined,\n        excludeDisabled,\n      );\n    }\n  }\n\n  return shouldUnregister\n    ? transformToNestObject(output)\n    : deepMerge(shallowFieldsState, transformToNestObject(output));\n};\n","import get from '../utils/get';\nimport isUndefined from '../utils/isUndefined';\nimport deepEqual from '../utils/deepEqual';\nimport {\n  FieldValues,\n  InternalFieldName,\n  FieldErrors,\n  FieldNamesMarkedBoolean,\n  FieldError,\n} from '../types';\n\nexport default <TFieldValues extends FieldValues>({\n  errors,\n  name,\n  error,\n  validFields,\n  fieldsWithValidation,\n}: {\n  errors: FieldErrors<TFieldValues>;\n  error: FieldError | undefined;\n  name: InternalFieldName<TFieldValues>;\n  validFields: FieldNamesMarkedBoolean<TFieldValues>;\n  fieldsWithValidation: FieldNamesMarkedBoolean<TFieldValues>;\n}): boolean => {\n  const isValid = isUndefined(error);\n  const previousError = get(errors, name);\n\n  return (\n    (isValid && !!previousError) ||\n    (!isValid && !deepEqual(previousError, error, true)) ||\n    (isValid && get(fieldsWithValidation, name) && !get(validFields, name))\n  );\n};\n","export default (value: unknown): value is RegExp => value instanceof RegExp;\n","import isObject from '../utils/isObject';\nimport isRegex from '../utils/isRegex';\nimport { ValidationRule } from '../types';\n\nexport default (validationData?: ValidationRule) =>\n  isObject(validationData) && !isRegex(validationData)\n    ? validationData\n    : {\n        value: validationData,\n        message: '',\n      };\n","export default (value: unknown): value is Function =>\n  typeof value === 'function';\n","import * as React from 'react';\nimport isString from '../utils/isString';\nimport { Message } from '../types';\n\nexport default (value: unknown): value is Message =>\n  isString(value) || React.isValidElement(value as JSX.Element);\n","import isBoolean from '../utils/isBoolean';\nimport isMessage from '../utils/isMessage';\nimport { FieldError, ValidateResult, Ref } from '../types';\n\nexport default function getValidateError(\n  result: ValidateResult,\n  ref: Ref,\n  type = 'validate',\n): FieldError | void {\n  if (isMessage(result) || (isBoolean(result) && !result)) {\n    return {\n      type,\n      message: isMessage(result) ? result : '',\n      ref,\n    };\n  }\n}\n","import {\n  InternalFieldName,\n  ValidateResult,\n  InternalFieldErrors,\n} from '../types';\n\nexport default <TFieldValues>(\n  name: InternalFieldName<TFieldValues>,\n  validateAllFieldCriteria: boolean,\n  errors: InternalFieldErrors<TFieldValues>,\n  type: string,\n  message: ValidateResult,\n) =>\n  validateAllFieldCriteria\n    ? {\n        ...errors[name],\n        types: {\n          ...(errors[name] && errors[name]!.types ? errors[name]!.types : {}),\n          [type]: message || true,\n        },\n      }\n    : {};\n","import * as React from 'react';\nimport getRadioValue from './getRadioValue';\nimport getCheckboxValue from './getCheckboxValue';\nimport isNullOrUndefined from '../utils/isNullOrUndefined';\nimport isRadioInput from '../utils/isRadioInput';\nimport getValueAndMessage from './getValueAndMessage';\nimport isCheckBoxInput from '../utils/isCheckBoxInput';\nimport isString from '../utils/isString';\nimport isEmptyObject from '../utils/isEmptyObject';\nimport isObject from '../utils/isObject';\nimport isFunction from '../utils/isFunction';\nimport getFieldsValue from './getFieldValue';\nimport isRegex from '../utils/isRegex';\nimport isBoolean from '../utils/isBoolean';\nimport isMessage from '../utils/isMessage';\nimport getValidateError from './getValidateError';\nimport appendErrors from './appendErrors';\nimport { INPUT_VALIDATION_RULES } from '../constants';\nimport {\n  Field,\n  FieldValues,\n  FieldRefs,\n  Message,\n  FieldError,\n  InternalFieldName,\n  InternalFieldErrors,\n} from '../types';\n\nexport default async <TFieldValues extends FieldValues>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  validateAllFieldCriteria: boolean,\n  {\n    ref,\n    ref: { value },\n    options,\n    required,\n    maxLength,\n    minLength,\n    min,\n    max,\n    pattern,\n    validate,\n  }: Field,\n  shallowFieldsStateRef: React.MutableRefObject<Record<string, any>>,\n): Promise<InternalFieldErrors<TFieldValues>> => {\n  const name: InternalFieldName<TFieldValues> = ref.name;\n  const error: InternalFieldErrors<TFieldValues> = {};\n  const isRadio = isRadioInput(ref);\n  const isCheckBox = isCheckBoxInput(ref);\n  const isRadioOrCheckbox = isRadio || isCheckBox;\n  const isEmpty = value === '';\n  const appendErrorsCurry = appendErrors.bind(\n    null,\n    name,\n    validateAllFieldCriteria,\n    error,\n  );\n  const getMinMaxMessage = (\n    exceedMax: boolean,\n    maxLengthMessage: Message,\n    minLengthMessage: Message,\n    maxType = INPUT_VALIDATION_RULES.maxLength,\n    minType = INPUT_VALIDATION_RULES.minLength,\n  ) => {\n    const message = exceedMax ? maxLengthMessage : minLengthMessage;\n    error[name] = {\n      type: exceedMax ? maxType : minType,\n      message,\n      ref,\n      ...(exceedMax\n        ? appendErrorsCurry(maxType, message)\n        : appendErrorsCurry(minType, message)),\n    };\n  };\n\n  if (\n    required &&\n    ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value))) ||\n      (isBoolean(value) && !value) ||\n      (isCheckBox && !getCheckboxValue(options).isValid) ||\n      (isRadio && !getRadioValue(options).isValid))\n  ) {\n    const { value, message } = isMessage(required)\n      ? { value: !!required, message: required }\n      : getValueAndMessage(required);\n\n    if (value) {\n      error[name] = {\n        type: INPUT_VALIDATION_RULES.required,\n        message,\n        ref: isRadioOrCheckbox\n          ? (((fieldsRef.current[name] as Field).options || [])[0] || {}).ref\n          : ref,\n        ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message),\n      };\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if ((!isNullOrUndefined(min) || !isNullOrUndefined(max)) && value !== '') {\n    let exceedMax;\n    let exceedMin;\n    const maxOutput = getValueAndMessage(max);\n    const minOutput = getValueAndMessage(min);\n\n    if (!isNaN(value)) {\n      const valueNumber =\n        (ref as HTMLInputElement).valueAsNumber || parseFloat(value);\n      if (!isNullOrUndefined(maxOutput.value)) {\n        exceedMax = valueNumber > maxOutput.value;\n      }\n      if (!isNullOrUndefined(minOutput.value)) {\n        exceedMin = valueNumber < minOutput.value;\n      }\n    } else {\n      const valueDate =\n        (ref as HTMLInputElement).valueAsDate || new Date(value);\n      if (isString(maxOutput.value)) {\n        exceedMax = valueDate > new Date(maxOutput.value);\n      }\n      if (isString(minOutput.value)) {\n        exceedMin = valueDate < new Date(minOutput.value);\n      }\n    }\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(\n        !!exceedMax,\n        maxOutput.message,\n        minOutput.message,\n        INPUT_VALIDATION_RULES.max,\n        INPUT_VALIDATION_RULES.min,\n      );\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (isString(value) && !isEmpty && (maxLength || minLength)) {\n    const maxLengthOutput = getValueAndMessage(maxLength);\n    const minLengthOutput = getValueAndMessage(minLength);\n    const exceedMax =\n      !isNullOrUndefined(maxLengthOutput.value) &&\n      value.length > maxLengthOutput.value;\n    const exceedMin =\n      !isNullOrUndefined(minLengthOutput.value) &&\n      value.length < minLengthOutput.value;\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(\n        exceedMax,\n        maxLengthOutput.message,\n        minLengthOutput.message,\n      );\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (isString(value) && pattern && !isEmpty) {\n    const { value: patternValue, message } = getValueAndMessage(pattern);\n\n    if (isRegex(patternValue) && !patternValue.test(value)) {\n      error[name] = {\n        type: INPUT_VALIDATION_RULES.pattern,\n        message,\n        ref,\n        ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message),\n      };\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (validate) {\n    const fieldValue = getFieldsValue(\n      fieldsRef,\n      name,\n      shallowFieldsStateRef,\n      false,\n      true,\n    );\n    const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\n\n    if (isFunction(validate)) {\n      const result = await validate(fieldValue);\n      const validateError = getValidateError(result, validateRef);\n\n      if (validateError) {\n        error[name] = {\n          ...validateError,\n          ...appendErrorsCurry(\n            INPUT_VALIDATION_RULES.validate,\n            validateError.message,\n          ),\n        };\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    } else if (isObject(validate)) {\n      let validationResult = {} as FieldError;\n      for (const [key, validateFunction] of Object.entries(validate)) {\n        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\n          break;\n        }\n\n        const validateResult = await validateFunction(fieldValue);\n        const validateError = getValidateError(\n          validateResult,\n          validateRef,\n          key,\n        );\n\n        if (validateError) {\n          validationResult = {\n            ...validateError,\n            ...appendErrorsCurry(key, validateError.message),\n          };\n\n          if (validateAllFieldCriteria) {\n            error[name] = validationResult;\n          }\n        }\n      }\n\n      if (!isEmptyObject(validationResult)) {\n        error[name] = {\n          ref: validateRef,\n          ...validationResult,\n        };\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    }\n  }\n\n  return error;\n};\n","import isPrimitive from './isPrimitive';\nimport isObject from './isObject';\nimport { FieldName } from '../types';\n\nexport const getPath = <TFieldValues>(\n  rootPath: FieldName<TFieldValues>,\n  values: any,\n  paths: FieldName<TFieldValues>[] = [],\n): FieldName<TFieldValues>[] => {\n  for (const property in values) {\n    const rootName = (rootPath +\n      (isObject(values)\n        ? `.${property}`\n        : `[${property}]`)) as FieldName<TFieldValues>;\n\n    isPrimitive(values[property])\n      ? paths.push(rootName)\n      : getPath(rootName, values[property], paths);\n  }\n\n  return paths;\n};\n","import get from '../utils/get';\nimport { getPath } from '../utils/getPath';\nimport isEmptyObject from '../utils/isEmptyObject';\nimport isUndefined from '../utils/isUndefined';\nimport isObject from '../utils/isObject';\nimport {\n  DeepPartial,\n  FieldValue,\n  FieldValues,\n  InternalFieldName,\n  UnpackNestedValue,\n} from '../types';\n\nexport default <TFieldValues extends FieldValues>(\n  fieldValues: TFieldValues,\n  fieldName: InternalFieldName<TFieldValues>,\n  watchFields: Set<InternalFieldName<TFieldValues>>,\n  inputValue: UnpackNestedValue<DeepPartial<TFieldValues>>,\n  isSingleField?: boolean,\n):\n  | FieldValue<TFieldValues>\n  | UnpackNestedValue<DeepPartial<TFieldValues>>\n  | undefined => {\n  let value = undefined;\n\n  watchFields.add(fieldName);\n\n  if (!isEmptyObject(fieldValues)) {\n    value = get(fieldValues, fieldName);\n\n    if (isObject(value) || Array.isArray(value)) {\n      getPath(fieldName, value).forEach((name) => watchFields.add(name));\n    }\n  }\n\n  return isUndefined(value)\n    ? isSingleField\n      ? inputValue\n      : get(inputValue, fieldName)\n    : value;\n};\n","export default ({\n  isOnBlur,\n  isOnChange,\n  isOnTouch,\n  isTouched,\n  isReValidateOnBlur,\n  isReValidateOnChange,\n  isBlurEvent,\n  isSubmitted,\n  isOnAll,\n}: {\n  isOnAll?: boolean;\n  isOnBlur?: boolean;\n  isOnChange?: boolean;\n  isReValidateOnBlur?: boolean;\n  isReValidateOnChange?: boolean;\n  isBlurEvent?: boolean;\n  isSubmitted?: boolean;\n  isOnTouch?: boolean;\n  isTouched?: boolean;\n}) => {\n  if (isOnAll) {\n    return false;\n  } else if (!isSubmitted && isOnTouch) {\n    return !(isTouched || isBlurEvent);\n  } else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\n    return !isBlurEvent;\n  } else if (isSubmitted ? isReValidateOnChange : isOnChange) {\n    return isBlurEvent;\n  }\n  return true;\n};\n","export default (name: string) => name.substring(0, name.indexOf('['));\n","import { FieldValues, InternalFieldName } from '../types';\n\nexport const isMatchFieldArrayName = (name: string, searchName: string) =>\n  RegExp(\n    `^${searchName}([|.)\\\\d+`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]'),\n  ).test(name);\n\nexport default (\n  names: Set<InternalFieldName<FieldValues>>,\n  name: InternalFieldName<FieldValues>,\n) => [...names].some((current) => isMatchFieldArrayName(name, current));\n","import { FieldElement } from '../types';\nimport { SELECT } from '../constants';\n\nexport default (element: FieldElement): element is HTMLSelectElement =>\n  element.type === `${SELECT}-one`;\n","import * as React from 'react';\nimport { Field, FieldRefs } from '../types';\nimport isDetached from './isDetached';\n\nexport default function onDomRemove<TFieldValues>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  removeFieldEventListenerAndRef: (\n    field: Field | undefined,\n    forceDelete?: boolean,\n  ) => void,\n): MutationObserver {\n  const observer = new MutationObserver((): void => {\n    for (const field of Object.values(fieldsRef.current)) {\n      if (field && field.options) {\n        for (const option of field.options) {\n          if (option && option.ref && isDetached(option.ref)) {\n            removeFieldEventListenerAndRef(field);\n          }\n        }\n      } else if (field && isDetached(field.ref)) {\n        removeFieldEventListenerAndRef(field);\n      }\n    }\n  });\n\n  observer.observe(window.document, {\n    childList: true,\n    subtree: true,\n  });\n\n  return observer;\n}\n","import { UNDEFINED } from '../constants';\n\nexport default typeof window !== UNDEFINED && typeof document !== UNDEFINED;\n","import isPrimitive from './isPrimitive';\nimport isHTMLElement from './isHTMLElement';\nimport isWeb from './isWeb';\n\nexport default function cloneObject<T extends unknown>(data: T): T {\n  let copy: any;\n\n  if (\n    isPrimitive(data) ||\n    (isWeb && (data instanceof File || isHTMLElement(data)))\n  ) {\n    return data;\n  }\n\n  if (\n    !['Set', 'Map', 'Object', 'Date', 'Array'].includes(\n      (data as Object).constructor?.name,\n    )\n  ) {\n    return data;\n  }\n\n  if (data instanceof Date) {\n    copy = new Date(data.getTime());\n    return copy;\n  }\n\n  if (data instanceof Set) {\n    copy = new Set();\n    for (const item of data) {\n      copy.add(item);\n    }\n    return copy;\n  }\n\n  if (data instanceof Map) {\n    copy = new Map();\n    for (const key of data.keys()) {\n      copy.set(key, cloneObject(data.get(key)));\n    }\n    return copy;\n  }\n\n  copy = Array.isArray(data) ? [] : {};\n\n  for (const key in data) {\n    copy[key] = cloneObject(data[key]);\n  }\n\n  return copy;\n}\n","import { VALIDATION_MODE } from '../constants';\nimport { Mode } from '../types';\n\nexport default (\n  mode?: Mode,\n): {\n  isOnSubmit: boolean;\n  isOnBlur: boolean;\n  isOnChange: boolean;\n  isOnAll: boolean;\n  isOnTouch: boolean;\n} => ({\n  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n  isOnBlur: mode === VALIDATION_MODE.onBlur,\n  isOnChange: mode === VALIDATION_MODE.onChange,\n  isOnAll: mode === VALIDATION_MODE.all,\n  isOnTouch: mode === VALIDATION_MODE.onTouched,\n});\n","import isRadioInput from './isRadioInput';\nimport isCheckBoxInput from './isCheckBoxInput';\nimport { FieldElement } from '../types';\n\nexport default (ref: FieldElement): ref is HTMLInputElement =>\n  isRadioInput(ref) || isCheckBoxInput(ref);\n","import * as React from 'react';\nimport attachEventListeners from './logic/attachEventListeners';\nimport transformToNestObject from './logic/transformToNestObject';\nimport focusOnErrorField from './logic/focusOnErrorField';\nimport findRemovedFieldAndRemoveListener from './logic/findRemovedFieldAndRemoveListener';\nimport setFieldArrayDirtyFields from './logic/setFieldArrayDirtyFields';\nimport getFieldsValues from './logic/getFieldsValues';\nimport getFieldValue from './logic/getFieldValue';\nimport isErrorStateChanged from './logic/isErrorStateChanged';\nimport validateField from './logic/validateField';\nimport assignWatchFields from './logic/assignWatchFields';\nimport skipValidation from './logic/skipValidation';\nimport getNodeParentName from './logic/getNodeParentName';\nimport deepEqual from './utils/deepEqual';\nimport isNameInFieldArray from './logic/isNameInFieldArray';\nimport isCheckBoxInput from './utils/isCheckBoxInput';\nimport isEmptyObject from './utils/isEmptyObject';\nimport isRadioInput from './utils/isRadioInput';\nimport isSelectInput from './utils/isSelectInput';\nimport isFileInput from './utils/isFileInput';\nimport onDomRemove from './utils/onDomRemove';\nimport isObject from './utils/isObject';\nimport { getPath } from './utils/getPath';\nimport isPrimitive from './utils/isPrimitive';\nimport isFunction from './utils/isFunction';\nimport isString from './utils/isString';\nimport isUndefined from './utils/isUndefined';\nimport get from './utils/get';\nimport set from './utils/set';\nimport unset from './utils/unset';\nimport isKey from './utils/isKey';\nimport cloneObject from './utils/cloneObject';\nimport modeChecker from './utils/validationModeChecker';\nimport isMultipleSelect from './utils/isMultipleSelect';\nimport compact from './utils/compact';\nimport isNullOrUndefined from './utils/isNullOrUndefined';\nimport isRadioOrCheckboxFunction from './utils/isRadioOrCheckbox';\nimport isWeb from './utils/isWeb';\nimport isHTMLElement from './utils/isHTMLElement';\nimport { EVENTS, UNDEFINED, VALIDATION_MODE } from './constants';\nimport {\n  UseFormMethods,\n  FieldValues,\n  UnpackNestedValue,\n  FieldName,\n  InternalFieldName,\n  FieldErrors,\n  Field,\n  FieldRefs,\n  UseFormOptions,\n  RegisterOptions,\n  SubmitHandler,\n  FieldElement,\n  FormStateProxy,\n  ReadFormState,\n  Ref,\n  HandleChange,\n  RadioOrCheckboxOption,\n  OmitResetState,\n  SetValueConfig,\n  ErrorOption,\n  FormState,\n  SubmitErrorHandler,\n  FieldNamesMarkedBoolean,\n  LiteralToPrimitive,\n  DeepPartial,\n  InternalNameSet,\n  DefaultValues,\n  FieldError,\n  SetFieldValue,\n  FieldArrayDefaultValues,\n  ResetFieldArrayFunctionRef,\n  UseWatchRenderFunctions,\n  RecordInternalNameSet,\n} from './types';\n\nconst isWindowUndefined = typeof window === UNDEFINED;\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\n\nexport function useForm<\n  TFieldValues extends FieldValues = FieldValues,\n  TContext extends object = object\n>({\n  mode = VALIDATION_MODE.onSubmit,\n  reValidateMode = VALIDATION_MODE.onChange,\n  resolver,\n  context,\n  defaultValues = {} as DefaultValues<TFieldValues>,\n  shouldFocusError = true,\n  shouldUnregister = true,\n  criteriaMode,\n}: UseFormOptions<TFieldValues, TContext> = {}): UseFormMethods<TFieldValues> {\n  const fieldsRef = React.useRef<FieldRefs<TFieldValues>>({});\n  const fieldArrayDefaultValuesRef = React.useRef<FieldArrayDefaultValues>({});\n  const fieldArrayValuesRef = React.useRef<FieldArrayDefaultValues>({});\n  const watchFieldsRef = React.useRef<InternalNameSet<TFieldValues>>(new Set());\n  const useWatchFieldsRef = React.useRef<RecordInternalNameSet<TFieldValues>>(\n    {},\n  );\n  const useWatchRenderFunctionsRef = React.useRef<UseWatchRenderFunctions>({});\n  const fieldsWithValidationRef = React.useRef<\n    FieldNamesMarkedBoolean<TFieldValues>\n  >({});\n  const validFieldsRef = React.useRef<FieldNamesMarkedBoolean<TFieldValues>>(\n    {},\n  );\n  const defaultValuesRef = React.useRef<DefaultValues<TFieldValues>>(\n    defaultValues,\n  );\n  const isUnMount = React.useRef(false);\n  const isWatchAllRef = React.useRef(false);\n  const handleChangeRef = React.useRef<HandleChange>();\n  const shallowFieldsStateRef = React.useRef({});\n  const resetFieldArrayFunctionRef = React.useRef<\n    ResetFieldArrayFunctionRef<TFieldValues>\n  >({});\n  const contextRef = React.useRef(context);\n  const resolverRef = React.useRef(resolver);\n  const fieldArrayNamesRef = React.useRef<InternalNameSet<TFieldValues>>(\n    new Set(),\n  );\n  const modeRef = React.useRef(modeChecker(mode));\n  const { isOnSubmit, isOnTouch } = modeRef.current;\n  const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\n  const [formState, setFormState] = React.useState<FormState<TFieldValues>>({\n    isDirty: false,\n    isValidating: false,\n    dirtyFields: {},\n    isSubmitted: false,\n    submitCount: 0,\n    touched: {},\n    isSubmitting: false,\n    isSubmitSuccessful: false,\n    isValid: !isOnSubmit,\n    errors: {},\n  });\n  const readFormStateRef = React.useRef<ReadFormState>({\n    isDirty: !isProxyEnabled,\n    dirtyFields: !isProxyEnabled,\n    touched: !isProxyEnabled || isOnTouch,\n    isValidating: !isProxyEnabled,\n    isSubmitting: !isProxyEnabled,\n    isValid: !isProxyEnabled,\n  });\n  const formStateRef = React.useRef(formState);\n  const observerRef = React.useRef<MutationObserver | undefined>();\n  const {\n    isOnBlur: isReValidateOnBlur,\n    isOnChange: isReValidateOnChange,\n  } = React.useRef(modeChecker(reValidateMode)).current;\n\n  contextRef.current = context;\n  resolverRef.current = resolver;\n  formStateRef.current = formState;\n  shallowFieldsStateRef.current = shouldUnregister\n    ? {}\n    : isEmptyObject(shallowFieldsStateRef.current)\n    ? cloneObject(defaultValues)\n    : shallowFieldsStateRef.current;\n\n  const updateFormState = React.useCallback(\n    (state: Partial<FormState<TFieldValues>> = {}) => {\n      if (!isUnMount.current) {\n        formStateRef.current = {\n          ...formStateRef.current,\n          ...state,\n        };\n        setFormState(formStateRef.current);\n      }\n    },\n    [],\n  );\n\n  const updateIsValidating = () =>\n    readFormStateRef.current.isValidating &&\n    updateFormState({\n      isValidating: true,\n    });\n\n  const shouldRenderBaseOnError = React.useCallback(\n    (\n      name: InternalFieldName<TFieldValues>,\n      error: FieldError | undefined,\n      shouldRender: boolean | null = false,\n      state: {\n        dirtyFields?: FieldNamesMarkedBoolean<TFieldValues>;\n        isDirty?: boolean;\n        touched?: FieldNamesMarkedBoolean<TFieldValues>;\n      } = {},\n      isValid?: boolean,\n    ): boolean | void => {\n      let shouldReRender =\n        shouldRender ||\n        isErrorStateChanged<TFieldValues>({\n          errors: formStateRef.current.errors,\n          error,\n          name,\n          validFields: validFieldsRef.current,\n          fieldsWithValidation: fieldsWithValidationRef.current,\n        });\n      const previousError = get(formStateRef.current.errors, name);\n\n      if (error) {\n        unset(validFieldsRef.current, name);\n        shouldReRender =\n          shouldReRender ||\n          !previousError ||\n          !deepEqual(previousError, error, true);\n        set(formStateRef.current.errors, name, error);\n      } else {\n        if (get(fieldsWithValidationRef.current, name) || resolverRef.current) {\n          set(validFieldsRef.current, name, true);\n          shouldReRender = shouldReRender || previousError;\n        }\n\n        unset(formStateRef.current.errors, name);\n      }\n\n      if (\n        (shouldReRender && !isNullOrUndefined(shouldRender)) ||\n        !isEmptyObject(state) ||\n        readFormStateRef.current.isValidating\n      ) {\n        updateFormState({\n          ...state,\n          ...(resolverRef.current ? { isValid: !!isValid } : {}),\n          isValidating: false,\n        });\n      }\n    },\n    [],\n  );\n\n  const setFieldValue = React.useCallback(\n    (name: FieldName<TFieldValues>, rawValue: SetFieldValue<TFieldValues>) => {\n      const { ref, options } = fieldsRef.current[name] as Field;\n      const value =\n        isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue)\n          ? ''\n          : rawValue;\n\n      if (isRadioInput(ref)) {\n        (options || []).forEach(\n          ({ ref: radioRef }: { ref: HTMLInputElement }) =>\n            (radioRef.checked = radioRef.value === value),\n        );\n      } else if (isFileInput(ref) && !isString(value)) {\n        ref.files = value as FileList;\n      } else if (isMultipleSelect(ref)) {\n        [...ref.options].forEach(\n          (selectRef) =>\n            (selectRef.selected = (value as string[]).includes(\n              selectRef.value,\n            )),\n        );\n      } else if (isCheckBoxInput(ref) && options) {\n        options.length > 1\n          ? options.forEach(\n              ({ ref: checkboxRef }) =>\n                (checkboxRef.checked = Array.isArray(value)\n                  ? !!(value as []).find(\n                      (data: string) => data === checkboxRef.value,\n                    )\n                  : value === checkboxRef.value),\n            )\n          : (options[0].ref.checked = !!value);\n      } else {\n        ref.value = value;\n      }\n    },\n    [],\n  );\n\n  const isFormDirty = React.useCallback(\n    (name?: string, data?: unknown[]): boolean => {\n      if (readFormStateRef.current.isDirty) {\n        const formValues = getValues();\n\n        name && data && set(formValues, name, data);\n\n        return !deepEqual(formValues, defaultValuesRef.current);\n      }\n\n      return false;\n    },\n    [],\n  );\n\n  const updateAndGetDirtyState = React.useCallback(\n    (\n      name: InternalFieldName<TFieldValues>,\n      shouldRender = true,\n    ): Partial<\n      Pick<FormState<TFieldValues>, 'dirtyFields' | 'isDirty' | 'touched'>\n    > => {\n      if (\n        readFormStateRef.current.isDirty ||\n        readFormStateRef.current.dirtyFields\n      ) {\n        const isFieldDirty = !deepEqual(\n          get(defaultValuesRef.current, name),\n          getFieldValue(fieldsRef, name, shallowFieldsStateRef),\n        );\n        const isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\n        const previousIsDirty = formStateRef.current.isDirty;\n\n        isFieldDirty\n          ? set(formStateRef.current.dirtyFields, name, true)\n          : unset(formStateRef.current.dirtyFields, name);\n\n        const state = {\n          isDirty: isFormDirty(),\n          dirtyFields: formStateRef.current.dirtyFields,\n        };\n\n        const isChanged =\n          (readFormStateRef.current.isDirty &&\n            previousIsDirty !== state.isDirty) ||\n          (readFormStateRef.current.dirtyFields &&\n            isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name));\n\n        isChanged && shouldRender && updateFormState(state);\n\n        return isChanged ? state : {};\n      }\n\n      return {};\n    },\n    [],\n  );\n\n  const executeValidation = React.useCallback(\n    async (\n      name: InternalFieldName<TFieldValues>,\n      skipReRender?: boolean | null,\n    ): Promise<boolean> => {\n      if (process.env.NODE_ENV !== 'production') {\n        if (!fieldsRef.current[name]) {\n          console.warn('📋 Field is missing with `name` attribute: ', name);\n          return false;\n        }\n      }\n\n      const error = (\n        await validateField<TFieldValues>(\n          fieldsRef,\n          isValidateAllFieldCriteria,\n          fieldsRef.current[name] as Field,\n          shallowFieldsStateRef,\n        )\n      )[name];\n\n      shouldRenderBaseOnError(name, error, skipReRender);\n\n      return isUndefined(error);\n    },\n    [shouldRenderBaseOnError, isValidateAllFieldCriteria],\n  );\n\n  const executeSchemaOrResolverValidation = React.useCallback(\n    async (\n      names:\n        | InternalFieldName<TFieldValues>\n        | InternalFieldName<TFieldValues>[],\n    ) => {\n      const { errors } = await resolverRef.current!(\n        getValues(),\n        contextRef.current,\n        isValidateAllFieldCriteria,\n      );\n      const previousFormIsValid = formStateRef.current.isValid;\n\n      if (Array.isArray(names)) {\n        const isInputsValid = names\n          .map((name) => {\n            const error = get(errors, name);\n\n            error\n              ? set(formStateRef.current.errors, name, error)\n              : unset(formStateRef.current.errors, name);\n\n            return !error;\n          })\n          .every(Boolean);\n\n        updateFormState({\n          isValid: isEmptyObject(errors),\n          isValidating: false,\n        });\n\n        return isInputsValid;\n      } else {\n        const error = get(errors, names);\n\n        shouldRenderBaseOnError(\n          names,\n          error,\n          previousFormIsValid !== isEmptyObject(errors),\n          {},\n          isEmptyObject(errors),\n        );\n\n        return !error;\n      }\n    },\n    [shouldRenderBaseOnError, isValidateAllFieldCriteria],\n  );\n\n  const trigger = React.useCallback(\n    async (\n      name?: FieldName<TFieldValues> | FieldName<TFieldValues>[],\n    ): Promise<boolean> => {\n      const fields = name || Object.keys(fieldsRef.current);\n\n      updateIsValidating();\n\n      if (resolverRef.current) {\n        return executeSchemaOrResolverValidation(fields);\n      }\n\n      if (Array.isArray(fields)) {\n        !name && (formStateRef.current.errors = {});\n        const result = await Promise.all(\n          fields.map(async (data) => await executeValidation(data, null)),\n        );\n        updateFormState({\n          isValidating: false,\n        });\n        return result.every(Boolean);\n      }\n\n      return await executeValidation(fields);\n    },\n    [executeSchemaOrResolverValidation, executeValidation],\n  );\n\n  const setInternalValues = React.useCallback(\n    (\n      name: FieldName<TFieldValues>,\n      value: SetFieldValue<TFieldValues>,\n      { shouldDirty, shouldValidate }: SetValueConfig,\n    ) => {\n      const data = {};\n      set(data, name, value);\n\n      for (const fieldName of getPath(name, value)) {\n        if (fieldsRef.current[fieldName]) {\n          setFieldValue(fieldName, get(data, fieldName));\n          shouldDirty && updateAndGetDirtyState(fieldName);\n          shouldValidate && trigger(fieldName as FieldName<TFieldValues>);\n        }\n      }\n    },\n    [trigger, setFieldValue, updateAndGetDirtyState],\n  );\n\n  const setInternalValue = React.useCallback(\n    (\n      name: FieldName<TFieldValues>,\n      value: SetFieldValue<TFieldValues>,\n      config: SetValueConfig,\n    ) => {\n      !shouldUnregister &&\n        !isPrimitive(value) &&\n        set(\n          shallowFieldsStateRef.current,\n          name,\n          Array.isArray(value) ? [...value] : { ...value },\n        );\n\n      if (fieldsRef.current[name]) {\n        setFieldValue(name, value);\n        config.shouldDirty && updateAndGetDirtyState(name);\n        config.shouldValidate && trigger(name as any);\n      } else if (!isPrimitive(value)) {\n        setInternalValues(name, value, config);\n\n        if (fieldArrayNamesRef.current.has(name)) {\n          const parentName = getNodeParentName(name) || name;\n          set(fieldArrayDefaultValuesRef.current, name, value);\n\n          resetFieldArrayFunctionRef.current[parentName]({\n            [parentName]: get(fieldArrayDefaultValuesRef.current, parentName),\n          } as UnpackNestedValue<DeepPartial<TFieldValues>>);\n\n          if (\n            (readFormStateRef.current.isDirty ||\n              readFormStateRef.current.dirtyFields) &&\n            config.shouldDirty\n          ) {\n            set(\n              formStateRef.current.dirtyFields,\n              name,\n              setFieldArrayDirtyFields(\n                value,\n                get(defaultValuesRef.current, name, []),\n                get(formStateRef.current.dirtyFields, name, []),\n              ),\n            );\n\n            updateFormState({\n              isDirty: !deepEqual(\n                { ...getValues(), [name]: value },\n                defaultValuesRef.current,\n              ),\n            });\n          }\n        }\n      }\n\n      !shouldUnregister && set(shallowFieldsStateRef.current, name, value);\n    },\n    [updateAndGetDirtyState, setFieldValue, setInternalValues],\n  );\n\n  const isFieldWatched = <T extends FieldName<TFieldValues>>(name: T) =>\n    isWatchAllRef.current ||\n    watchFieldsRef.current.has(name) ||\n    watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\n\n  const renderWatchedInputs = <T extends FieldName<FieldValues>>(\n    name: T,\n  ): boolean => {\n    let found = true;\n\n    if (!isEmptyObject(useWatchFieldsRef.current)) {\n      for (const key in useWatchFieldsRef.current) {\n        if (\n          !name ||\n          !useWatchFieldsRef.current[key].size ||\n          useWatchFieldsRef.current[key].has(name) ||\n          useWatchFieldsRef.current[key].has(getNodeParentName(name))\n        ) {\n          useWatchRenderFunctionsRef.current[key]();\n          found = false;\n        }\n      }\n    }\n\n    return found;\n  };\n\n  function setValue(\n    name: FieldName<TFieldValues>,\n    value: SetFieldValue<TFieldValues>,\n    config?: SetValueConfig,\n  ): void {\n    setInternalValue(name, value, config || {});\n    isFieldWatched(name) && updateFormState();\n    renderWatchedInputs(name);\n  }\n\n  handleChangeRef.current = handleChangeRef.current\n    ? handleChangeRef.current\n    : async ({ type, target }: Event): Promise<void | boolean> => {\n        let name = (target as Ref)!.name;\n        const field = fieldsRef.current[name];\n        let error;\n        let isValid;\n\n        if (field) {\n          const isBlurEvent = type === EVENTS.BLUR;\n          const shouldSkipValidation = skipValidation({\n            isBlurEvent,\n            isReValidateOnChange,\n            isReValidateOnBlur,\n            isTouched: !!get(formStateRef.current.touched, name),\n            isSubmitted: formStateRef.current.isSubmitted,\n            ...modeRef.current,\n          });\n          let state = updateAndGetDirtyState(name, false);\n          let shouldRender =\n            !isEmptyObject(state) ||\n            (!isBlurEvent && isFieldWatched(name as FieldName<TFieldValues>));\n\n          if (\n            isBlurEvent &&\n            !get(formStateRef.current.touched, name) &&\n            readFormStateRef.current.touched\n          ) {\n            set(formStateRef.current.touched, name, true);\n            state = {\n              ...state,\n              touched: formStateRef.current.touched,\n            };\n          }\n\n          if (!shouldUnregister && isCheckBoxInput(target as Ref)) {\n            set(\n              shallowFieldsStateRef.current,\n              name,\n              getFieldValue(fieldsRef, name),\n            );\n          }\n\n          if (shouldSkipValidation) {\n            !isBlurEvent && renderWatchedInputs(name);\n            return (\n              (!isEmptyObject(state) ||\n                (shouldRender && isEmptyObject(state))) &&\n              updateFormState(state)\n            );\n          }\n\n          updateIsValidating();\n\n          if (resolverRef.current) {\n            const { errors } = await resolverRef.current(\n              getValues(),\n              contextRef.current,\n              isValidateAllFieldCriteria,\n            );\n            const previousFormIsValid = formStateRef.current.isValid;\n            error = get(errors, name);\n\n            if (\n              isCheckBoxInput(target as Ref) &&\n              !error &&\n              resolverRef.current\n            ) {\n              const parentNodeName = getNodeParentName(name);\n              const currentError = get(errors, parentNodeName, {});\n              currentError.type &&\n                currentError.message &&\n                (error = currentError);\n\n              if (\n                parentNodeName &&\n                (currentError ||\n                  get(formStateRef.current.errors, parentNodeName))\n              ) {\n                name = parentNodeName;\n              }\n            }\n\n            isValid = isEmptyObject(errors);\n\n            previousFormIsValid !== isValid && (shouldRender = true);\n          } else {\n            error = (\n              await validateField<TFieldValues>(\n                fieldsRef,\n                isValidateAllFieldCriteria,\n                field,\n                shallowFieldsStateRef,\n              )\n            )[name];\n          }\n\n          !isBlurEvent && renderWatchedInputs(name);\n          shouldRenderBaseOnError(name, error, shouldRender, state, isValid);\n        }\n      };\n\n  function setFieldArrayDefaultValues<T extends FieldValues>(data: T): T {\n    if (!shouldUnregister) {\n      let copy = cloneObject(data);\n\n      for (const value of fieldArrayNamesRef.current) {\n        if (isKey(value) && !copy[value]) {\n          copy = {\n            ...copy,\n            [value]: [],\n          };\n        }\n      }\n\n      return copy;\n    }\n    return data;\n  }\n\n  function getValues(): UnpackNestedValue<TFieldValues>;\n  function getValues<TFieldName extends string, TFieldValue extends unknown>(\n    name: TFieldName,\n  ): TFieldName extends keyof TFieldValues\n    ? UnpackNestedValue<TFieldValues>[TFieldName]\n    : TFieldValue;\n  function getValues<TFieldName extends keyof TFieldValues>(\n    names: TFieldName[],\n  ): UnpackNestedValue<Pick<TFieldValues, TFieldName>>;\n  function getValues(payload?: string | string[]): unknown {\n    if (isString(payload)) {\n      return getFieldValue(fieldsRef, payload, shallowFieldsStateRef);\n    }\n\n    if (Array.isArray(payload)) {\n      const data = {};\n\n      for (const name of payload) {\n        set(data, name, getFieldValue(fieldsRef, name, shallowFieldsStateRef));\n      }\n\n      return data;\n    }\n\n    return setFieldArrayDefaultValues(\n      getFieldsValues(\n        fieldsRef,\n        cloneObject(shallowFieldsStateRef.current),\n        shouldUnregister,\n      ),\n    );\n  }\n\n  const validateResolver = React.useCallback(\n    async (values = {}) => {\n      const newDefaultValues = isEmptyObject(fieldsRef.current)\n        ? defaultValuesRef.current\n        : {};\n\n      const { errors } =\n        (await resolverRef.current!(\n          {\n            ...newDefaultValues,\n            ...getValues(),\n            ...values,\n          },\n          contextRef.current,\n          isValidateAllFieldCriteria,\n        )) || {};\n      const isValid = isEmptyObject(errors);\n\n      formStateRef.current.isValid !== isValid &&\n        updateFormState({\n          isValid,\n        });\n    },\n    [isValidateAllFieldCriteria],\n  );\n\n  const removeFieldEventListener = React.useCallback(\n    (field: Field, forceDelete?: boolean) => {\n      findRemovedFieldAndRemoveListener(\n        fieldsRef,\n        handleChangeRef.current!,\n        field,\n        shallowFieldsStateRef,\n        shouldUnregister,\n        forceDelete,\n      );\n\n      if (shouldUnregister) {\n        unset(validFieldsRef.current, field.ref.name);\n        unset(fieldsWithValidationRef.current, field.ref.name);\n      }\n    },\n    [shouldUnregister],\n  );\n\n  const updateWatchedValue = React.useCallback((name: string) => {\n    if (isWatchAllRef.current) {\n      updateFormState();\n    } else {\n      for (const watchField of watchFieldsRef.current) {\n        if (watchField.startsWith(name)) {\n          updateFormState();\n          break;\n        }\n      }\n\n      renderWatchedInputs(name);\n    }\n  }, []);\n\n  const removeFieldEventListenerAndRef = React.useCallback(\n    (field?: Field, forceDelete?: boolean) => {\n      if (field) {\n        removeFieldEventListener(field, forceDelete);\n\n        if (shouldUnregister && !compact(field.options || []).length) {\n          unset(formStateRef.current.errors, field.ref.name);\n          set(formStateRef.current.dirtyFields, field.ref.name, true);\n\n          updateFormState({\n            isDirty: isFormDirty(),\n          });\n\n          readFormStateRef.current.isValid &&\n            resolverRef.current &&\n            validateResolver();\n          updateWatchedValue(field.ref.name);\n        }\n      }\n    },\n    [validateResolver, removeFieldEventListener],\n  );\n\n  function clearErrors(\n    name?: FieldName<TFieldValues> | FieldName<TFieldValues>[],\n  ): void {\n    name &&\n      (Array.isArray(name) ? name : [name]).forEach((inputName) =>\n        fieldsRef.current[inputName] && isKey(inputName)\n          ? delete formStateRef.current.errors[inputName]\n          : unset(formStateRef.current.errors, inputName),\n      );\n\n    updateFormState({\n      errors: name ? formStateRef.current.errors : {},\n    });\n  }\n\n  function setError(name: FieldName<TFieldValues>, error: ErrorOption) {\n    const ref = (fieldsRef.current[name] || {})!.ref;\n\n    set(formStateRef.current.errors, name, {\n      ...error,\n      ref,\n    });\n\n    updateFormState({\n      isValid: false,\n    });\n\n    error.shouldFocus && ref && ref.focus && ref.focus();\n  }\n\n  const watchInternal = React.useCallback(\n    <T>(fieldNames?: string | string[], defaultValue?: T, watchId?: string) => {\n      const watchFields = watchId\n        ? useWatchFieldsRef.current[watchId]\n        : watchFieldsRef.current;\n      let fieldValues = getFieldsValues<TFieldValues>(\n        fieldsRef,\n        cloneObject(shallowFieldsStateRef.current),\n        shouldUnregister,\n        false,\n        fieldNames,\n      );\n\n      if (isString(fieldNames)) {\n        const parentNodeName = getNodeParentName(fieldNames) || fieldNames;\n\n        if (fieldArrayNamesRef.current.has(parentNodeName)) {\n          fieldValues = {\n            ...fieldArrayValuesRef.current,\n            ...fieldValues,\n          };\n        }\n\n        return assignWatchFields<TFieldValues>(\n          fieldValues,\n          fieldNames,\n          watchFields,\n          isUndefined(get(defaultValuesRef.current, fieldNames))\n            ? defaultValue\n            : get(defaultValuesRef.current, fieldNames),\n          true,\n        );\n      }\n\n      const combinedDefaultValues = isUndefined(defaultValue)\n        ? defaultValuesRef.current\n        : defaultValue;\n\n      if (Array.isArray(fieldNames)) {\n        return fieldNames.reduce(\n          (previous, name) => ({\n            ...previous,\n            [name]: assignWatchFields<TFieldValues>(\n              fieldValues,\n              name,\n              watchFields,\n              combinedDefaultValues as UnpackNestedValue<\n                DeepPartial<TFieldValues>\n              >,\n            ),\n          }),\n          {},\n        );\n      }\n\n      isWatchAllRef.current = isUndefined(watchId);\n\n      return transformToNestObject(\n        (!isEmptyObject(fieldValues) && fieldValues) ||\n          (combinedDefaultValues as FieldValues),\n      );\n    },\n    [],\n  );\n\n  function watch(): UnpackNestedValue<TFieldValues>;\n  function watch<\n    TFieldName extends string,\n    TFieldValue extends TFieldValues[TFieldName]\n  >(\n    name?: TFieldName,\n    defaultValue?: UnpackNestedValue<LiteralToPrimitive<TFieldValue>>,\n  ): UnpackNestedValue<LiteralToPrimitive<TFieldValue>>;\n  function watch<TFieldName extends keyof TFieldValues>(\n    names: TFieldName[],\n    defaultValues?: UnpackNestedValue<\n      DeepPartial<Pick<TFieldValues, TFieldName>>\n    >,\n  ): UnpackNestedValue<Pick<TFieldValues, TFieldName>>;\n  function watch(\n    names: string[],\n    defaultValues?: UnpackNestedValue<DeepPartial<TFieldValues>>,\n  ): UnpackNestedValue<DeepPartial<TFieldValues>>;\n  function watch(\n    fieldNames?: string | string[] | undefined,\n    defaultValue?: unknown,\n  ): unknown {\n    return watchInternal(fieldNames, defaultValue);\n  }\n\n  function unregister(\n    name: FieldName<TFieldValues> | FieldName<TFieldValues>[],\n  ): void {\n    for (const fieldName of Array.isArray(name) ? name : [name]) {\n      removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true);\n    }\n  }\n\n  function registerFieldRef<TFieldElement extends FieldElement<TFieldValues>>(\n    ref: TFieldElement & Ref,\n    options: RegisterOptions | null = {},\n  ): ((name: InternalFieldName<TFieldValues>) => void) | void {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!ref.name) {\n        return console.warn(\n          '📋 Field is missing `name` attribute',\n          ref,\n          `https://react-hook-form.com/api#useForm`,\n        );\n      }\n\n      if (\n        fieldArrayNamesRef.current.has(ref.name.split(/\\[\\d+\\]$/)[0]) &&\n        !RegExp(\n          `^${ref.name.split(/\\[\\d+\\]$/)[0]}[\\\\d+].\\\\w+`\n            .replace(/\\[/g, '\\\\[')\n            .replace(/\\]/g, '\\\\]'),\n        ).test(ref.name)\n      ) {\n        return console.warn(\n          '📋 `name` prop should be in object shape: name=\"test[index].name\"',\n          ref,\n          'https://react-hook-form.com/api#useFieldArray',\n        );\n      }\n    }\n\n    const { name, type, value } = ref;\n    const fieldRefAndValidationOptions = {\n      ref,\n      ...options,\n    };\n    const fields = fieldsRef.current;\n    const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\n    const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n    const compareRef = (currentRef: Ref) =>\n      isWeb && (!isHTMLElement(ref) || currentRef === ref);\n    let field = fields[name] as Field;\n    let isEmptyDefaultValue = true;\n    let defaultValue;\n\n    if (\n      field &&\n      (isRadioOrCheckbox\n        ? Array.isArray(field.options) &&\n          compact(field.options).find((option) => {\n            return value === option.ref.value && compareRef(option.ref);\n          })\n        : compareRef(field.ref))\n    ) {\n      fields[name] = {\n        ...field,\n        ...options,\n      };\n      return;\n    }\n\n    if (type) {\n      field = isRadioOrCheckbox\n        ? {\n            options: [\n              ...compact((field && field.options) || []),\n              {\n                ref,\n              } as RadioOrCheckboxOption,\n            ],\n            ref: { type, name },\n            ...options,\n          }\n        : {\n            ...fieldRefAndValidationOptions,\n          };\n    } else {\n      field = fieldRefAndValidationOptions;\n    }\n\n    fields[name] = field;\n\n    const isEmptyUnmountFields = isUndefined(\n      get(shallowFieldsStateRef.current, name),\n    );\n\n    if (!isEmptyObject(defaultValuesRef.current) || !isEmptyUnmountFields) {\n      defaultValue = get(\n        isEmptyUnmountFields\n          ? defaultValuesRef.current\n          : shallowFieldsStateRef.current,\n        name,\n      );\n      isEmptyDefaultValue = isUndefined(defaultValue);\n\n      if (!isEmptyDefaultValue && !isFieldArray) {\n        setFieldValue(name as FieldName<TFieldValues>, defaultValue);\n      }\n    }\n\n    if (!isEmptyObject(options)) {\n      set(fieldsWithValidationRef.current, name, true);\n\n      if (!isOnSubmit && readFormStateRef.current.isValid) {\n        validateField(\n          fieldsRef,\n          isValidateAllFieldCriteria,\n          field,\n          shallowFieldsStateRef,\n        ).then((error: FieldErrors) => {\n          const previousFormIsValid = formStateRef.current.isValid;\n\n          isEmptyObject(error)\n            ? set(validFieldsRef.current, name, true)\n            : unset(validFieldsRef.current, name);\n\n          previousFormIsValid !== isEmptyObject(error) && updateFormState();\n        });\n      }\n    }\n\n    if (shouldUnregister && !(isFieldArray && isEmptyDefaultValue)) {\n      !isFieldArray && unset(formStateRef.current.dirtyFields, name);\n    }\n\n    if (type) {\n      attachEventListeners(\n        isRadioOrCheckbox && field.options\n          ? field.options[field.options.length - 1]\n          : field,\n        isRadioOrCheckbox || isSelectInput(ref),\n        handleChangeRef.current,\n      );\n    }\n  }\n\n  function register<TFieldElement extends FieldElement<TFieldValues>>(\n    options?: RegisterOptions,\n  ): (ref: (TFieldElement & Ref) | null) => void;\n  function register(\n    name: FieldName<TFieldValues>,\n    options?: RegisterOptions,\n  ): void;\n  function register<TFieldElement extends FieldElement<TFieldValues>>(\n    ref: (TFieldElement & Ref) | null,\n    options?: RegisterOptions,\n  ): void;\n  function register<TFieldElement extends FieldElement<TFieldValues>>(\n    refOrRegisterOptions?:\n      | FieldName<TFieldValues>\n      | RegisterOptions\n      | (TFieldElement & Ref)\n      | null,\n    options?: RegisterOptions,\n  ): ((ref: (TFieldElement & Ref) | null) => void) | void {\n    if (!isWindowUndefined) {\n      if (isString(refOrRegisterOptions)) {\n        registerFieldRef({ name: refOrRegisterOptions }, options);\n      } else if (\n        isObject(refOrRegisterOptions) &&\n        'name' in refOrRegisterOptions\n      ) {\n        registerFieldRef(refOrRegisterOptions, options);\n      } else {\n        return (ref: (TFieldElement & Ref) | null) =>\n          ref && registerFieldRef(ref, refOrRegisterOptions);\n      }\n    }\n  }\n\n  const handleSubmit = React.useCallback(\n    <TSubmitFieldValues extends FieldValues = TFieldValues>(\n      onValid: SubmitHandler<TSubmitFieldValues>,\n      onInvalid?: SubmitErrorHandler<TFieldValues>,\n    ) => async (e?: React.BaseSyntheticEvent): Promise<void> => {\n      if (e && e.preventDefault) {\n        e.preventDefault();\n        e.persist();\n      }\n      let fieldErrors: FieldErrors<TFieldValues> = {};\n      let fieldValues = setFieldArrayDefaultValues(\n        getFieldsValues(\n          fieldsRef,\n          cloneObject(shallowFieldsStateRef.current),\n          shouldUnregister,\n          true,\n        ),\n      );\n\n      readFormStateRef.current.isSubmitting &&\n        updateFormState({\n          isSubmitting: true,\n        });\n\n      try {\n        if (resolverRef.current) {\n          const { errors, values } = await resolverRef.current(\n            fieldValues,\n            contextRef.current,\n            isValidateAllFieldCriteria,\n          );\n          formStateRef.current.errors = fieldErrors = errors;\n          fieldValues = values;\n        } else {\n          for (const field of Object.values(fieldsRef.current)) {\n            if (field) {\n              const { name } = field.ref;\n\n              const fieldError = await validateField(\n                fieldsRef,\n                isValidateAllFieldCriteria,\n                field,\n                shallowFieldsStateRef,\n              );\n\n              if (fieldError[name]) {\n                set(fieldErrors, name, fieldError[name]);\n                unset(validFieldsRef.current, name);\n              } else if (get(fieldsWithValidationRef.current, name)) {\n                unset(formStateRef.current.errors, name);\n                set(validFieldsRef.current, name, true);\n              }\n            }\n          }\n        }\n\n        if (\n          isEmptyObject(fieldErrors) &&\n          Object.keys(formStateRef.current.errors).every(\n            (name) => name in fieldsRef.current,\n          )\n        ) {\n          updateFormState({\n            errors: {},\n            isSubmitting: true,\n          });\n          await onValid(fieldValues, e);\n        } else {\n          formStateRef.current.errors = {\n            ...formStateRef.current.errors,\n            ...fieldErrors,\n          };\n          onInvalid && (await onInvalid(formStateRef.current.errors, e));\n          shouldFocusError &&\n            focusOnErrorField(fieldsRef.current, formStateRef.current.errors);\n        }\n      } finally {\n        formStateRef.current.isSubmitting = false;\n        updateFormState({\n          isSubmitted: true,\n          isSubmitting: false,\n          isSubmitSuccessful: isEmptyObject(formStateRef.current.errors),\n          submitCount: formStateRef.current.submitCount + 1,\n        });\n      }\n    },\n    [shouldFocusError, isValidateAllFieldCriteria],\n  );\n\n  const resetRefs = ({\n    errors,\n    isDirty,\n    isSubmitted,\n    touched,\n    isValid,\n    submitCount,\n    dirtyFields,\n  }: OmitResetState) => {\n    if (!isValid) {\n      validFieldsRef.current = {};\n      fieldsWithValidationRef.current = {};\n    }\n\n    fieldArrayDefaultValuesRef.current = {};\n    watchFieldsRef.current = new Set();\n    isWatchAllRef.current = false;\n\n    updateFormState({\n      submitCount: submitCount ? formStateRef.current.submitCount : 0,\n      isDirty: isDirty ? formStateRef.current.isDirty : false,\n      isSubmitted: isSubmitted ? formStateRef.current.isSubmitted : false,\n      isValid: isValid ? formStateRef.current.isValid : false,\n      dirtyFields: dirtyFields ? formStateRef.current.dirtyFields : {},\n      touched: touched ? formStateRef.current.touched : {},\n      errors: errors ? formStateRef.current.errors : {},\n      isSubmitting: false,\n      isSubmitSuccessful: false,\n    });\n  };\n\n  const reset = (\n    values?: DefaultValues<TFieldValues>,\n    omitResetState: OmitResetState = {},\n  ): void => {\n    if (isWeb) {\n      for (const field of Object.values(fieldsRef.current)) {\n        if (field) {\n          const { ref, options } = field;\n          const inputRef =\n            isRadioOrCheckboxFunction(ref) && Array.isArray(options)\n              ? options[0].ref\n              : ref;\n\n          if (isHTMLElement(inputRef)) {\n            try {\n              inputRef.closest('form')!.reset();\n              break;\n            } catch {}\n          }\n        }\n      }\n    }\n\n    fieldsRef.current = {};\n    defaultValuesRef.current = { ...(values || defaultValuesRef.current) };\n    values && renderWatchedInputs('');\n\n    Object.values(resetFieldArrayFunctionRef.current).forEach(\n      (resetFieldArray) => isFunction(resetFieldArray) && resetFieldArray(),\n    );\n\n    shallowFieldsStateRef.current = shouldUnregister\n      ? {}\n      : cloneObject(values || defaultValuesRef.current);\n\n    resetRefs(omitResetState);\n  };\n\n  React.useEffect(() => {\n    resolver && readFormStateRef.current.isValid && validateResolver();\n    observerRef.current =\n      observerRef.current || !isWeb\n        ? observerRef.current\n        : onDomRemove(fieldsRef, removeFieldEventListenerAndRef);\n  }, [removeFieldEventListenerAndRef, defaultValuesRef.current]);\n\n  React.useEffect(\n    () => () => {\n      observerRef.current && observerRef.current.disconnect();\n      isUnMount.current = true;\n\n      if (process.env.NODE_ENV !== 'production') {\n        return;\n      }\n\n      Object.values(fieldsRef.current).forEach((field) =>\n        removeFieldEventListenerAndRef(field, true),\n      );\n    },\n    [],\n  );\n\n  if (!resolver && readFormStateRef.current.isValid) {\n    formState.isValid =\n      deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) &&\n      isEmptyObject(formStateRef.current.errors);\n  }\n\n  const commonProps = {\n    trigger,\n    setValue: React.useCallback(setValue, [setInternalValue, trigger]),\n    getValues: React.useCallback(getValues, []),\n    register: React.useCallback(register, [defaultValuesRef.current]),\n    unregister: React.useCallback(unregister, []),\n    formState: isProxyEnabled\n      ? new Proxy(formState, {\n          get: (obj, prop: keyof FormStateProxy) => {\n            if (process.env.NODE_ENV !== 'production') {\n              if (prop === 'isValid' && isOnSubmit) {\n                console.warn(\n                  '📋 `formState.isValid` is applicable with `onTouched`, `onChange` or `onBlur` mode. https://react-hook-form.com/api#formState',\n                );\n              }\n            }\n\n            if (prop in obj) {\n              readFormStateRef.current[prop] = true;\n              return obj[prop];\n            }\n\n            return undefined;\n          },\n        })\n      : formState,\n  };\n\n  const control = React.useMemo(\n    () => ({\n      isFormDirty,\n      updateWatchedValue,\n      shouldUnregister,\n      updateFormState,\n      removeFieldEventListener,\n      watchInternal,\n      mode: modeRef.current,\n      reValidateMode: {\n        isReValidateOnBlur,\n        isReValidateOnChange,\n      },\n      validateResolver: resolver ? validateResolver : undefined,\n      fieldsRef,\n      resetFieldArrayFunctionRef,\n      useWatchFieldsRef,\n      useWatchRenderFunctionsRef,\n      fieldArrayDefaultValuesRef,\n      validFieldsRef,\n      fieldsWithValidationRef,\n      fieldArrayNamesRef,\n      readFormStateRef,\n      formStateRef,\n      defaultValuesRef,\n      shallowFieldsStateRef,\n      fieldArrayValuesRef,\n      ...commonProps,\n    }),\n    [\n      defaultValuesRef.current,\n      updateWatchedValue,\n      shouldUnregister,\n      removeFieldEventListener,\n      watchInternal,\n    ],\n  );\n\n  return {\n    watch,\n    control,\n    handleSubmit,\n    reset: React.useCallback(reset, []),\n    clearErrors: React.useCallback(clearErrors, []),\n    setError: React.useCallback(setError, []),\n    errors: formState.errors,\n    ...commonProps,\n  };\n}\n","import * as React from 'react';\nimport { UseFormMethods, FieldValues, FormProviderProps } from './types';\n\nconst FormContext = React.createContext<UseFormMethods | null>(null);\n\nFormContext.displayName = 'RHFContext';\n\nexport const useFormContext = <\n  TFieldValues extends FieldValues\n>(): UseFormMethods<TFieldValues> =>\n  React.useContext(FormContext) as UseFormMethods<TFieldValues>;\n\nexport const FormProvider = <TFieldValues extends FieldValues>({\n  children,\n  ...props\n}: FormProviderProps<TFieldValues>) => (\n  <FormContext.Provider value={{ ...props } as UseFormMethods}>\n    {children}\n  </FormContext.Provider>\n);\n","import { UNDEFINED } from '../constants';\n\nexport default () => {\n  const d =\n    typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\n\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16 + d) % 16 | 0;\n\n    return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\n  });\n};\n","import isUndefined from './isUndefined';\nimport compact from './compact';\n\nfunction removeAtIndexes<T>(data: T[], indexes: number[]): T[] {\n  let i = 0;\n  const temp = [...data];\n\n  for (const index of indexes) {\n    temp.splice(index - i, 1);\n    i++;\n  }\n\n  return compact(temp).length ? temp : [];\n}\n\nexport default <T>(data: T[], index?: number | number[]): T[] =>\n  isUndefined(index)\n    ? []\n    : removeAtIndexes(\n        data,\n        (Array.isArray(index) ? index : [index]).sort((a, b) => a - b),\n      );\n","import isUndefined from './isUndefined';\n\nexport default <T>(\n  data: (T | undefined)[],\n  from: number,\n  to: number,\n): (T | undefined)[] => {\n  if (Array.isArray(data)) {\n    if (isUndefined(data[to])) {\n      data[to] = undefined;\n    }\n    data.splice(to, 0, data.splice(from, 1)[0]);\n    return data;\n  }\n\n  return [];\n};\n","export default <T>(data: T[], indexA: number, indexB: number): void => {\n  const temp = [data[indexB], data[indexA]];\n  data[indexA] = temp[0];\n  data[indexB] = temp[1];\n};\n","export default function prepend<T>(data: T[]): (T | undefined)[];\nexport default function prepend<T>(data: T[], value: T | T[]): T[];\nexport default function prepend<T>(\n  data: T[],\n  value?: T | T[],\n): (T | undefined)[] {\n  return [...(Array.isArray(value) ? value : [value || undefined]), ...data];\n}\n","export default function insert<T>(data: T[], index: number): (T | undefined)[];\nexport default function insert<T>(\n  data: T[],\n  index: number,\n  value: T | T[],\n): T[];\nexport default function insert<T>(\n  data: T[],\n  index: number,\n  value?: T | T[],\n): (T | undefined)[] {\n  return [\n    ...data.slice(0, index),\n    ...(Array.isArray(value) ? value : [value || undefined]),\n    ...data.slice(index),\n  ];\n}\n","export default <T>(value: T | T[]): undefined[] | undefined =>\n  Array.isArray(value) ? Array(value.length).fill(undefined) : undefined;\n","import isObject from './isObject';\n\nexport default <T>(value: T) =>\n  ((Array.isArray(value) ? value : [value]) as T[]).map((data) => {\n    if (isObject(data)) {\n      const object: Record<string, boolean> = {};\n\n      for (const key in data) {\n        object[key] = true;\n      }\n\n      return object;\n    }\n\n    return true;\n  });\n","import * as React from 'react';\nimport { useFormContext } from './useFormContext';\nimport setFieldArrayDirtyFields from './logic/setFieldArrayDirtyFields';\nimport { isMatchFieldArrayName } from './logic/isNameInFieldArray';\nimport generateId from './logic/generateId';\nimport getFieldArrayParentName from './logic/getNodeParentName';\nimport get from './utils/get';\nimport set from './utils/set';\nimport removeArrayAt from './utils/remove';\nimport unset from './utils/unset';\nimport moveArrayAt from './utils/move';\nimport swapArrayAt from './utils/swap';\nimport prependAt from './utils/prepend';\nimport insertAt from './utils/insert';\nimport fillEmptyArray from './utils/fillEmptyArray';\nimport fillBooleanArray from './utils/fillBooleanArray';\nimport compact from './utils/compact';\nimport cloneObject from './utils/cloneObject';\nimport {\n  Field,\n  FieldValues,\n  UseFieldArrayOptions,\n  Control,\n  ArrayField,\n  UnpackNestedValue,\n  DeepPartial,\n  UseFieldArrayMethods,\n} from './types';\n\nconst mapIds = <\n  TFieldArrayValues extends FieldValues = FieldValues,\n  TKeyName extends string = 'id'\n>(\n  values: Partial<TFieldArrayValues>[] = [],\n  keyName: TKeyName,\n  skipWarn?: boolean,\n): Partial<ArrayField<TFieldArrayValues, TKeyName>>[] => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!skipWarn) {\n      for (const value of values) {\n        if (typeof value === 'object') {\n          if (keyName in value) {\n            console.warn(\n              `📋 useFieldArray fieldValues contain the keyName \\`${keyName}\\` which is reserved for use by useFieldArray. https://react-hook-form.com/api#useFieldArray`,\n            );\n\n            break;\n          }\n        } else {\n          console.warn(\n            `📋 useFieldArray input's name should be in object shape instead of flat array. https://react-hook-form.com/api#useFieldArray`,\n          );\n\n          break;\n        }\n      }\n    }\n  }\n\n  return values.map((value: Partial<TFieldArrayValues>) => ({\n    [keyName]: value[keyName] || generateId(),\n    ...value,\n  }));\n};\n\nexport const useFieldArray = <\n  TFieldArrayValues extends FieldValues = FieldValues,\n  TKeyName extends string = 'id',\n  TControl extends Control = Control\n>({\n  control,\n  name,\n  keyName = 'id' as TKeyName,\n}: UseFieldArrayOptions<TKeyName, TControl>): UseFieldArrayMethods<\n  TFieldArrayValues,\n  TKeyName\n> => {\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error(\n        '📋 useFieldArray is missing `control` prop. https://react-hook-form.com/api#useFieldArray',\n      );\n    }\n  }\n\n  const focusIndexRef = React.useRef(-1);\n  const isUnMount = React.useRef(false);\n  const {\n    isFormDirty,\n    updateWatchedValue,\n    resetFieldArrayFunctionRef,\n    fieldArrayNamesRef,\n    fieldsRef,\n    defaultValuesRef,\n    removeFieldEventListener,\n    formStateRef,\n    shallowFieldsStateRef,\n    updateFormState,\n    readFormStateRef,\n    validFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayDefaultValuesRef,\n    validateResolver,\n    getValues,\n    shouldUnregister,\n    fieldArrayValuesRef,\n  } = control || methods.control;\n\n  const getDefaultValues = <T>(values: T) =>\n    get(shouldUnregister ? values : shallowFieldsStateRef.current, name, []);\n\n  const fieldArrayParentName = getFieldArrayParentName(name);\n  const memoizedDefaultValues = React.useRef<Partial<TFieldArrayValues>[]>([\n    ...(get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)\n      ? getDefaultValues(fieldArrayDefaultValuesRef.current)\n      : getDefaultValues(defaultValuesRef.current)),\n  ]);\n  const [fields, setFields] = React.useState<\n    Partial<ArrayField<TFieldArrayValues, TKeyName>>[]\n  >(mapIds(memoizedDefaultValues.current, keyName));\n  set(fieldArrayValuesRef.current, name, compact(fields));\n\n  const omitKey = <T extends (Partial<TFieldArrayValues> | undefined)[]>(\n    fields: T,\n  ) => fields.map(({ [keyName]: omitted, ...rest } = {}) => rest);\n\n  fieldArrayNamesRef.current.add(name);\n\n  const getFieldArrayValue = React.useCallback(\n    () => get(fieldArrayValuesRef.current, name, []),\n    [name],\n  );\n\n  const getCurrentFieldsValues = () =>\n    mapIds<TFieldArrayValues, TKeyName>(\n      get(getValues(), name, getFieldArrayValue()).map(\n        (item: Partial<TFieldArrayValues>, index: number) => ({\n          ...getFieldArrayValue()[index],\n          ...item,\n        }),\n      ),\n      keyName,\n      true,\n    );\n\n  fieldArrayNamesRef.current.add(name);\n\n  if (\n    fieldArrayParentName &&\n    !get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)\n  ) {\n    set(\n      fieldArrayDefaultValuesRef.current,\n      fieldArrayParentName,\n      cloneObject(get(defaultValuesRef.current, fieldArrayParentName)),\n    );\n  }\n\n  const setFieldAndValidState = (\n    fieldsValues: Partial<ArrayField<TFieldArrayValues, TKeyName>>[],\n  ) => {\n    setFields(fieldsValues);\n    set(fieldArrayValuesRef.current, name, fieldsValues);\n\n    if (readFormStateRef.current.isValid && validateResolver) {\n      const values = getValues();\n      set(values, name, fieldsValues);\n      validateResolver(values);\n    }\n  };\n\n  const resetFields = () => {\n    for (const key in fieldsRef.current) {\n      if (isMatchFieldArrayName(key, name)) {\n        removeFieldEventListener(fieldsRef.current[key] as Field, true);\n        delete fieldsRef.current[key];\n      }\n    }\n  };\n\n  const cleanup = <T>(ref: T) =>\n    !compact(get(ref, name, [])).length && unset(ref, name);\n\n  const updateDirtyFieldsWithDefaultValues = <\n    T extends (Partial<TFieldArrayValues> | undefined)[]\n  >(\n    updatedFieldArrayValues?: T,\n  ) => {\n    if (updatedFieldArrayValues) {\n      set(\n        formStateRef.current.dirtyFields,\n        name,\n        setFieldArrayDirtyFields(\n          omitKey(updatedFieldArrayValues),\n          get(defaultValuesRef.current, name, []),\n          get(formStateRef.current.dirtyFields, name, []),\n        ),\n      );\n    }\n  };\n\n  const batchStateUpdate = <\n    T extends Function,\n    K extends (Partial<TFieldArrayValues> | undefined)[]\n  >(\n    method: T,\n    args: {\n      argA?: unknown;\n      argB?: unknown;\n      argC?: unknown;\n      argD?: unknown;\n    },\n    updatedFieldValues?: K,\n    updatedFormValues: (Partial<TFieldArrayValues> | undefined)[] = [],\n    shouldSet = true,\n    shouldUpdateValid = false,\n  ) => {\n    if (get(shallowFieldsStateRef.current, name)) {\n      const output = method(\n        get(shallowFieldsStateRef.current, name),\n        args.argA,\n        args.argB,\n      );\n      shouldSet && set(shallowFieldsStateRef.current, name, output);\n    }\n\n    if (get(fieldArrayDefaultValuesRef.current, name)) {\n      const output = method(\n        get(fieldArrayDefaultValuesRef.current, name),\n        args.argA,\n        args.argB,\n      );\n      shouldSet && set(fieldArrayDefaultValuesRef.current, name, output);\n    }\n\n    if (Array.isArray(get(formStateRef.current.errors, name))) {\n      const output = method(\n        get(formStateRef.current.errors, name),\n        args.argA,\n        args.argB,\n      );\n      shouldSet && set(formStateRef.current.errors, name, output);\n      cleanup(formStateRef.current.errors);\n    }\n\n    if (\n      readFormStateRef.current.touched &&\n      get(formStateRef.current.touched, name)\n    ) {\n      const output = method(\n        get(formStateRef.current.touched, name),\n        args.argA,\n        args.argB,\n      );\n      shouldSet && set(formStateRef.current.touched, name, output);\n      cleanup(formStateRef.current.touched);\n    }\n\n    if (\n      readFormStateRef.current.dirtyFields ||\n      readFormStateRef.current.isDirty\n    ) {\n      set(\n        formStateRef.current.dirtyFields,\n        name,\n        setFieldArrayDirtyFields(\n          omitKey(updatedFormValues),\n          get(defaultValuesRef.current, name, []),\n          get(formStateRef.current.dirtyFields, name, []),\n        ),\n      );\n      updateDirtyFieldsWithDefaultValues(updatedFieldValues);\n      cleanup(formStateRef.current.dirtyFields);\n    }\n\n    if (\n      shouldUpdateValid &&\n      readFormStateRef.current.isValid &&\n      !validateResolver\n    ) {\n      set(\n        validFieldsRef.current,\n        name,\n        method(get(validFieldsRef.current, name, []), args.argA),\n      );\n      cleanup(validFieldsRef.current);\n\n      set(\n        fieldsWithValidationRef.current,\n        name,\n        method(get(fieldsWithValidationRef.current, name, []), args.argA),\n      );\n      cleanup(fieldsWithValidationRef.current);\n    }\n\n    if (!isUnMount.current && readFormStateRef.current.isDirty) {\n      updateFormState({\n        isDirty: isFormDirty(name, omitKey(updatedFormValues)),\n      });\n    }\n  };\n\n  const append = (\n    value: Partial<TFieldArrayValues> | Partial<TFieldArrayValues>[],\n    shouldFocus = true,\n  ) => {\n    const appendValue = Array.isArray(value) ? value : [value];\n    const updateFormValues = [\n      ...getCurrentFieldsValues(),\n      ...mapIds(appendValue, keyName),\n    ];\n    setFieldAndValidState(updateFormValues);\n\n    if (\n      readFormStateRef.current.dirtyFields ||\n      readFormStateRef.current.isDirty\n    ) {\n      updateDirtyFieldsWithDefaultValues(updateFormValues);\n\n      updateFormState({\n        isDirty: true,\n        dirtyFields: formStateRef.current.dirtyFields,\n      });\n    }\n\n    !shouldUnregister &&\n      set(shallowFieldsStateRef.current, name, [\n        ...(get(shallowFieldsStateRef.current, name) || []),\n        ...cloneObject(appendValue),\n      ]);\n\n    focusIndexRef.current = shouldFocus\n      ? get(fieldArrayValuesRef.current, name).length - 1\n      : -1;\n  };\n\n  const prepend = (\n    value: Partial<TFieldArrayValues> | Partial<TFieldArrayValues>[],\n    shouldFocus = true,\n  ) => {\n    const emptyArray = fillEmptyArray(value);\n    const updatedFieldArrayValues = prependAt(\n      getCurrentFieldsValues(),\n      mapIds(Array.isArray(value) ? value : [value], keyName),\n    );\n\n    setFieldAndValidState(updatedFieldArrayValues);\n    resetFields();\n    batchStateUpdate(\n      prependAt,\n      {\n        argA: emptyArray,\n        argC: fillBooleanArray(value),\n      },\n      updatedFieldArrayValues,\n    );\n    focusIndexRef.current = shouldFocus ? 0 : -1;\n  };\n\n  const remove = (index?: number | number[]) => {\n    const fieldValues = getCurrentFieldsValues();\n    const updatedFieldValues: (\n      | Partial<TFieldArrayValues>\n      | undefined\n    )[] = removeArrayAt(fieldValues, index);\n    setFieldAndValidState(\n      updatedFieldValues as Partial<ArrayField<TFieldArrayValues, TKeyName>>[],\n    );\n    resetFields();\n    batchStateUpdate(\n      removeArrayAt,\n      {\n        argA: index,\n        argC: index,\n      },\n      updatedFieldValues,\n      removeArrayAt(fieldValues, index),\n      true,\n      true,\n    );\n  };\n\n  const insert = (\n    index: number,\n    value: Partial<TFieldArrayValues> | Partial<TFieldArrayValues>[],\n    shouldFocus = true,\n  ) => {\n    const emptyArray = fillEmptyArray(value);\n    const fieldValues = getCurrentFieldsValues();\n    const updatedFieldArrayValues = insertAt(\n      fieldValues,\n      index,\n      mapIds(Array.isArray(value) ? value : [value], keyName),\n    );\n\n    setFieldAndValidState(updatedFieldArrayValues);\n    resetFields();\n    batchStateUpdate(\n      insertAt,\n      {\n        argA: index,\n        argB: emptyArray,\n        argC: index,\n        argD: fillBooleanArray(value),\n      },\n      updatedFieldArrayValues,\n      insertAt(fieldValues, index),\n    );\n    focusIndexRef.current = shouldFocus ? index : -1;\n  };\n\n  const swap = (indexA: number, indexB: number) => {\n    const fieldValues = getCurrentFieldsValues();\n    swapArrayAt(fieldValues, indexA, indexB);\n    resetFields();\n    setFieldAndValidState([...fieldValues]);\n    batchStateUpdate(\n      swapArrayAt,\n      {\n        argA: indexA,\n        argB: indexB,\n        argC: indexA,\n        argD: indexB,\n      },\n      undefined,\n      fieldValues,\n      false,\n    );\n  };\n\n  const move = (from: number, to: number) => {\n    const fieldValues = getCurrentFieldsValues();\n    moveArrayAt(fieldValues, from, to);\n    resetFields();\n    setFieldAndValidState([...fieldValues]);\n    batchStateUpdate(\n      moveArrayAt,\n      {\n        argA: from,\n        argB: to,\n        argC: from,\n        argD: to,\n      },\n      undefined,\n      fieldValues,\n      false,\n    );\n  };\n\n  React.useEffect(() => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!name) {\n        console.warn(\n          '📋 useFieldArray is missing `name` attribute. https://react-hook-form.com/api#useFieldArray',\n        );\n      }\n    }\n\n    const defaultValues = get(fieldArrayDefaultValuesRef.current, name);\n\n    if (defaultValues && fields.length < defaultValues.length) {\n      set(fieldArrayDefaultValuesRef.current, name, defaultValues.slice(1));\n    }\n\n    updateWatchedValue(name);\n\n    if (focusIndexRef.current > -1) {\n      for (const key in fieldsRef.current) {\n        const field = fieldsRef.current[key];\n        if (\n          key.startsWith(`${name}[${focusIndexRef.current}]`) &&\n          field!.ref.focus\n        ) {\n          field!.ref.focus();\n          break;\n        }\n      }\n    }\n\n    focusIndexRef.current = -1;\n  }, [fields, name]);\n\n  React.useEffect(() => {\n    const resetFunctions = resetFieldArrayFunctionRef.current;\n    const fieldArrayNames = fieldArrayNamesRef.current;\n\n    if (!getFieldArrayParentName(name)) {\n      resetFunctions[name] = <TFieldValues>(\n        data?: UnpackNestedValue<DeepPartial<TFieldValues>>,\n      ) => {\n        resetFields();\n        !data && unset(fieldArrayDefaultValuesRef.current, name);\n        unset(shallowFieldsStateRef.current, name);\n        memoizedDefaultValues.current = get(\n          data || defaultValuesRef.current,\n          name,\n        );\n        if (!isUnMount.current) {\n          setFields(mapIds(memoizedDefaultValues.current, keyName));\n        }\n      };\n    }\n\n    return () => {\n      isUnMount.current = true;\n      shouldUnregister && remove();\n      resetFields();\n      delete resetFunctions[name];\n      unset(fieldArrayValuesRef.current, name);\n      fieldArrayNames.delete(name);\n    };\n  }, []);\n\n  return {\n    swap: React.useCallback(swap, [name]),\n    move: React.useCallback(move, [name]),\n    prepend: React.useCallback(prepend, [name]),\n    append: React.useCallback(append, [name]),\n    remove: React.useCallback(remove, [name]),\n    insert: React.useCallback(insert, [name]),\n    fields: compact(fields),\n  };\n};\n","import isUndefined from '../utils/isUndefined';\nimport isObject from '../utils/isObject';\nimport isPrimitive from '../utils/isPrimitive';\n\nexport default (event: any) =>\n  isPrimitive(event) ||\n  !isObject(event.target) ||\n  (isObject(event.target) && !event.type)\n    ? event\n    : isUndefined(event.target.value)\n    ? event.target.checked\n    : event.target.value;\n","import { useFormContext } from './useFormContext';\nimport isNameInFieldArray from './logic/isNameInFieldArray';\nimport isUndefined from './utils/isUndefined';\nimport get from './utils/get';\nimport * as React from 'react';\nimport isFunction from './utils/isFunction';\nimport skipValidation from './logic/skipValidation';\nimport getInputValue from './logic/getInputValue';\nimport set from './utils/set';\nimport {\n  FieldValues,\n  UseControllerOptions,\n  UseControllerMethods,\n} from './types';\n\nexport function useController<TFieldValues extends FieldValues = FieldValues>({\n  name,\n  rules,\n  defaultValue,\n  control,\n  onFocus,\n}: UseControllerOptions<TFieldValues>): UseControllerMethods<TFieldValues> {\n  const methods = useFormContext<TFieldValues>();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error(\n        '📋 Controller is missing `control` prop. https://react-hook-form.com/api#Controller',\n      );\n    }\n  }\n\n  const {\n    defaultValuesRef,\n    setValue,\n    register,\n    unregister,\n    trigger,\n    mode,\n    reValidateMode: { isReValidateOnBlur, isReValidateOnChange },\n    formState,\n    formStateRef: {\n      current: { isSubmitted, touched, errors },\n    },\n    updateFormState,\n    readFormStateRef,\n    fieldsRef,\n    fieldArrayNamesRef,\n    shallowFieldsStateRef,\n  } = control || methods.control;\n\n  const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\n  const getInitialValue = () =>\n    !isUndefined(get(shallowFieldsStateRef.current, name)) && isNotFieldArray\n      ? get(shallowFieldsStateRef.current, name)\n      : isUndefined(defaultValue)\n      ? get(defaultValuesRef.current, name)\n      : defaultValue;\n  const [value, setInputStateValue] = React.useState(getInitialValue());\n  const valueRef = React.useRef(value);\n  const ref = React.useRef({\n    focus: () => null,\n  });\n  const onFocusRef = React.useRef(\n    onFocus ||\n      (() => {\n        if (isFunction(ref.current.focus)) {\n          ref.current.focus();\n        }\n\n        if (process.env.NODE_ENV !== 'production') {\n          if (!isFunction(ref.current.focus)) {\n            console.warn(\n              `📋 'ref' from Controller render prop must be attached to a React component or a DOM Element whose ref provides a 'focus()' method`,\n            );\n          }\n        }\n      }),\n  );\n\n  const shouldValidate = React.useCallback(\n    (isBlurEvent?: boolean) =>\n      !skipValidation({\n        isBlurEvent,\n        isReValidateOnBlur,\n        isReValidateOnChange,\n        isSubmitted,\n        isTouched: !!get(touched, name),\n        ...mode,\n      }),\n    [\n      isReValidateOnBlur,\n      isReValidateOnChange,\n      isSubmitted,\n      touched,\n      name,\n      mode,\n    ],\n  );\n\n  const commonTask = React.useCallback(([event]: any[]) => {\n    const data = getInputValue(event);\n    setInputStateValue(data);\n    valueRef.current = data;\n    return data;\n  }, []);\n\n  const registerField = React.useCallback(\n    (shouldUpdateValue?: boolean) => {\n      if (process.env.NODE_ENV !== 'production') {\n        if (!name) {\n          return console.warn(\n            '📋 Field is missing `name` prop. https://react-hook-form.com/api#Controller',\n          );\n        }\n      }\n\n      if (fieldsRef.current[name]) {\n        fieldsRef.current[name] = {\n          ref: fieldsRef.current[name]!.ref,\n          ...rules,\n        };\n      } else {\n        register(\n          Object.defineProperties(\n            {\n              name,\n              focus: onFocusRef.current,\n            },\n            {\n              value: {\n                set(data) {\n                  setInputStateValue(data);\n                  valueRef.current = data;\n                },\n                get() {\n                  return valueRef.current;\n                },\n              },\n            },\n          ),\n          rules,\n        );\n\n        shouldUpdateValue = isUndefined(get(defaultValuesRef.current, name));\n      }\n\n      shouldUpdateValue &&\n        isNotFieldArray &&\n        setInputStateValue(getInitialValue());\n    },\n    [rules, name, register],\n  );\n\n  React.useEffect(() => () => unregister(name), [name]);\n\n  React.useEffect(() => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (isUndefined(value)) {\n        console.warn(\n          `📋 ${name} is missing in the 'defaultValue' prop of either its Controller (https://react-hook-form.com/api#Controller) or useForm (https://react-hook-form.com/api#useForm)`,\n        );\n      }\n\n      if (!isNotFieldArray && isUndefined(defaultValue)) {\n        console.warn(\n          '📋 Controller is missing `defaultValue` prop when using `useFieldArray`. https://react-hook-form.com/api#Controller',\n        );\n      }\n    }\n\n    registerField();\n  }, [registerField]);\n\n  React.useEffect(() => {\n    !fieldsRef.current[name] && registerField(true);\n  });\n\n  const onBlur = React.useCallback(() => {\n    if (readFormStateRef.current.touched && !get(touched, name)) {\n      set(touched, name, true);\n      updateFormState({\n        touched,\n      });\n    }\n\n    shouldValidate(true) && trigger(name);\n  }, [name, updateFormState, shouldValidate, trigger, readFormStateRef]);\n\n  const onChange = React.useCallback(\n    (...event: any[]) =>\n      setValue(name, commonTask(event), {\n        shouldValidate: shouldValidate(),\n        shouldDirty: true,\n      }),\n    [setValue, name, shouldValidate],\n  );\n\n  return {\n    field: {\n      onChange,\n      onBlur,\n      name,\n      value,\n      ref,\n    },\n    meta: Object.defineProperties(\n      {\n        invalid: !!get(errors, name),\n      },\n      {\n        isDirty: {\n          get() {\n            return !!get(formState.dirtyFields, name);\n          },\n        },\n        isTouched: {\n          get() {\n            return !!get(formState.touched, name);\n          },\n        },\n      },\n    ),\n  };\n}\n","import * as React from 'react';\nimport { useFormContext } from './useFormContext';\nimport isUndefined from './utils/isUndefined';\nimport isString from './utils/isString';\nimport generateId from './logic/generateId';\nimport get from './utils/get';\nimport {\n  DeepPartial,\n  UseWatchOptions,\n  FieldValues,\n  UnpackNestedValue,\n  Control,\n} from './types';\n\nexport function useWatch<TWatchFieldValues extends FieldValues>(props: {\n  defaultValue?: UnpackNestedValue<DeepPartial<TWatchFieldValues>>;\n  control?: Control;\n}): UnpackNestedValue<DeepPartial<TWatchFieldValues>>;\nexport function useWatch<TWatchFieldValue extends any>(props: {\n  name: string;\n  control?: Control;\n}): undefined | UnpackNestedValue<TWatchFieldValue>;\nexport function useWatch<TWatchFieldValue extends any>(props: {\n  name: string;\n  defaultValue: UnpackNestedValue<TWatchFieldValue>;\n  control?: Control;\n}): UnpackNestedValue<TWatchFieldValue>;\nexport function useWatch<TWatchFieldValues extends FieldValues>(props: {\n  name: string[];\n  defaultValue?: UnpackNestedValue<DeepPartial<TWatchFieldValues>>;\n  control?: Control;\n}): UnpackNestedValue<DeepPartial<TWatchFieldValues>>;\nexport function useWatch<TWatchFieldValues>({\n  control,\n  name,\n  defaultValue,\n}: UseWatchOptions): TWatchFieldValues {\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error(\n        '📋 useWatch is missing `control` prop. https://react-hook-form.com/api#useWatch',\n      );\n    }\n  }\n\n  const {\n    useWatchFieldsRef,\n    useWatchRenderFunctionsRef,\n    watchInternal,\n    defaultValuesRef,\n  } = control || methods.control;\n  const updateValue = React.useState<unknown>()[1];\n  const idRef = React.useRef<string>();\n  const defaultValueRef = React.useRef(defaultValue);\n\n  React.useEffect(() => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (name === '') {\n        console.warn(\n          '📋 useWatch is missing `name` attribute. https://react-hook-form.com/api#useWatch',\n        );\n      }\n    }\n\n    const id = (idRef.current = generateId());\n    const watchFieldsHookRender = useWatchRenderFunctionsRef.current;\n    const watchFieldsHook = useWatchFieldsRef.current;\n    watchFieldsHook[id] = new Set();\n    watchFieldsHookRender[id] = () => updateValue({});\n    watchInternal(name, defaultValueRef.current, id);\n\n    return () => {\n      delete watchFieldsHook[id];\n      delete watchFieldsHookRender[id];\n    };\n  }, [\n    name,\n    useWatchRenderFunctionsRef,\n    useWatchFieldsRef,\n    watchInternal,\n    defaultValueRef,\n  ]);\n\n  return idRef.current\n    ? watchInternal(name, defaultValueRef.current, idRef.current)\n    : isUndefined(defaultValue)\n    ? isString(name)\n      ? get(defaultValuesRef.current, name)\n      : Array.isArray(name)\n      ? name.reduce(\n          (previous, inputName) => ({\n            ...previous,\n            [inputName]: get(defaultValuesRef.current, inputName),\n          }),\n          {},\n        )\n      : defaultValuesRef.current\n    : defaultValue;\n}\n","import * as React from 'react';\nimport { useController } from './useController';\nimport { ControllerProps, FieldValues } from './types';\n\ntype NativeInputs = 'input' | 'select' | 'textarea';\n\nconst Controller = <\n  TAs extends React.ReactElement | React.ComponentType<any> | NativeInputs,\n  TFieldValues extends FieldValues = FieldValues\n>(\n  props: ControllerProps<TAs, TFieldValues>,\n) => {\n  const { rules, as, render, defaultValue, control, onFocus, ...rest } = props;\n  const { field, meta } = useController(props);\n\n  const componentProps = {\n    ...rest,\n    ...field,\n  };\n\n  return as\n    ? React.isValidElement(as)\n      ? React.cloneElement(as, componentProps)\n      : React.createElement(as as NativeInputs, componentProps as any)\n    : render\n    ? render(field, meta)\n    : null;\n};\n\nexport { Controller };\n"]},"metadata":{},"sourceType":"module"}