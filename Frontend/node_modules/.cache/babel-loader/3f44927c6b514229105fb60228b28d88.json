{"ast":null,"code":"'use strict';\n\nconst process = require('process');\n\nconst Timers = require('timers');\n\nconst Readable = require('stream').Readable;\n\nconst Command = require('./command.js');\n\nconst Packets = require('../packets/index.js');\n\nconst getTextParser = require('../parsers/text_parser.js');\n\nconst ServerStatus = require('../constants/server_status.js');\n\nconst EmptyPacket = new Packets.Packet(0, Buffer.allocUnsafe(4), 0, 4); // http://dev.mysql.com/doc/internals/en/com-query.html\n\nclass Query extends Command {\n  constructor(options, callback) {\n    super();\n    this.sql = options.sql;\n    this.values = options.values;\n    this._queryOptions = options;\n    this.namedPlaceholders = options.namedPlaceholders || false;\n    this.onResult = callback;\n    this.timeout = options.timeout;\n    this.queryTimeout = null;\n    this._fieldCount = 0;\n    this._rowParser = null;\n    this._fields = [];\n    this._rows = [];\n    this._receivedFieldsCount = 0;\n    this._resultIndex = 0;\n    this._localStream = null;\n\n    this._unpipeStream = function () {};\n\n    this._streamFactory = options.infileStreamFactory;\n    this._connection = null;\n  }\n\n  then() {\n    const err = \"You have tried to call .then(), .catch(), or invoked await on the result of query that is not a promise, which is a programming error. Try calling con.promise().query(), or require('mysql2/promise') instead of 'mysql2' for a promise-compatible version of the query interface. To learn how to use async/await or Promises check out documentation at https://www.npmjs.com/package/mysql2#using-promise-wrapper, or the mysql2 documentation at https://github.com/sidorares/node-mysql2/tree/master/documentation/Promise-Wrapper.md\"; // eslint-disable-next-line\n\n    console.log(err);\n    throw new Error(err);\n  }\n  /* eslint no-unused-vars: [\"error\", { \"argsIgnorePattern\": \"^_\" }] */\n\n\n  start(_packet, connection) {\n    if (connection.config.debug) {\n      // eslint-disable-next-line\n      console.log('        Sending query command: %s', this.sql);\n    }\n\n    this._connection = connection;\n    this.options = Object.assign({}, connection.config, this._queryOptions);\n\n    this._setTimeout();\n\n    const cmdPacket = new Packets.Query(this.sql, connection.config.charsetNumber);\n    connection.writePacket(cmdPacket.toPacket(1));\n    return Query.prototype.resultsetHeader;\n  }\n\n  done() {\n    this._unpipeStream(); // if all ready timeout, return null directly\n\n\n    if (this.timeout && !this.queryTimeout) {\n      return null;\n    } // else clear timer\n\n\n    if (this.queryTimeout) {\n      Timers.clearTimeout(this.queryTimeout);\n      this.queryTimeout = null;\n    }\n\n    if (this.onResult) {\n      let rows, fields;\n\n      if (this._resultIndex === 0) {\n        rows = this._rows[0];\n        fields = this._fields[0];\n      } else {\n        rows = this._rows;\n        fields = this._fields;\n      }\n\n      if (fields) {\n        process.nextTick(() => {\n          this.onResult(null, rows, fields);\n        });\n      } else {\n        process.nextTick(() => {\n          this.onResult(null, rows);\n        });\n      }\n    }\n\n    return null;\n  }\n\n  doneInsert(rs) {\n    if (this._localStreamError) {\n      if (this.onResult) {\n        this.onResult(this._localStreamError, rs);\n      } else {\n        this.emit('error', this._localStreamError);\n      }\n\n      return null;\n    }\n\n    this._rows.push(rs);\n\n    this._fields.push(void 0);\n\n    this.emit('fields', void 0);\n    this.emit('result', rs);\n\n    if (rs.serverStatus & ServerStatus.SERVER_MORE_RESULTS_EXISTS) {\n      this._resultIndex++;\n      return this.resultsetHeader;\n    }\n\n    return this.done();\n  }\n\n  resultsetHeader(packet, connection) {\n    const rs = new Packets.ResultSetHeader(packet, connection);\n    this._fieldCount = rs.fieldCount;\n\n    if (connection.config.debug) {\n      // eslint-disable-next-line\n      console.log(`        Resultset header received, expecting ${rs.fieldCount} column definition packets`);\n    }\n\n    if (this._fieldCount === 0) {\n      return this.doneInsert(rs);\n    }\n\n    if (this._fieldCount === null) {\n      return this._streamLocalInfile(connection, rs.infileName);\n    }\n\n    this._receivedFieldsCount = 0;\n\n    this._rows.push([]);\n\n    this._fields.push([]);\n\n    return this.readField;\n  }\n\n  _streamLocalInfile(connection, path) {\n    if (this._streamFactory) {\n      this._localStream = this._streamFactory(path);\n    } else {\n      this._localStreamError = new Error(`As a result of LOCAL INFILE command server wants to read ${path} file, but as of v2.0 you must provide streamFactory option returning ReadStream.`);\n      connection.writePacket(EmptyPacket);\n      return this.infileOk;\n    }\n\n    const onConnectionError = () => {\n      this._unpipeStream();\n    };\n\n    const onDrain = () => {\n      this._localStream.resume();\n    };\n\n    const onPause = () => {\n      this._localStream.pause();\n    };\n\n    const onData = function (data) {\n      const dataWithHeader = Buffer.allocUnsafe(data.length + 4);\n      data.copy(dataWithHeader, 4);\n      connection.writePacket(new Packets.Packet(0, dataWithHeader, 0, dataWithHeader.length));\n    };\n\n    const onEnd = () => {\n      connection.removeListener('error', onConnectionError);\n      connection.writePacket(EmptyPacket);\n    };\n\n    const onError = err => {\n      this._localStreamError = err;\n      connection.removeListener('error', onConnectionError);\n      connection.writePacket(EmptyPacket);\n    };\n\n    this._unpipeStream = () => {\n      connection.stream.removeListener('pause', onPause);\n      connection.stream.removeListener('drain', onDrain);\n\n      this._localStream.removeListener('data', onData);\n\n      this._localStream.removeListener('end', onEnd);\n\n      this._localStream.removeListener('error', onError);\n    };\n\n    connection.stream.on('pause', onPause);\n    connection.stream.on('drain', onDrain);\n\n    this._localStream.on('data', onData);\n\n    this._localStream.on('end', onEnd);\n\n    this._localStream.on('error', onError);\n\n    connection.once('error', onConnectionError);\n    return this.infileOk;\n  }\n\n  readField(packet, connection) {\n    this._receivedFieldsCount++; // Often there is much more data in the column definition than in the row itself\n    // If you set manually _fields[0] to array of ColumnDefinition's (from previous call)\n    // you can 'cache' result of parsing. Field packets still received, but ignored in that case\n    // this is the reason _receivedFieldsCount exist (otherwise we could just use current length of fields array)\n\n    if (this._fields[this._resultIndex].length !== this._fieldCount) {\n      const field = new Packets.ColumnDefinition(packet, connection.clientEncoding);\n\n      this._fields[this._resultIndex].push(field);\n\n      if (connection.config.debug) {\n        /* eslint-disable no-console */\n        console.log('        Column definition:');\n        console.log(`          name: ${field.name}`);\n        console.log(`          type: ${field.columnType}`);\n        console.log(`         flags: ${field.flags}`);\n        /* eslint-enable no-console */\n      }\n    } // last field received\n\n\n    if (this._receivedFieldsCount === this._fieldCount) {\n      const fields = this._fields[this._resultIndex];\n      this.emit('fields', fields);\n      this._rowParser = new (getTextParser(fields, this.options, connection.config))();\n      return Query.prototype.fieldsEOF;\n    }\n\n    return Query.prototype.readField;\n  }\n\n  fieldsEOF(packet, connection) {\n    // check EOF\n    if (!packet.isEOF()) {\n      return connection.protocolError('Expected EOF packet');\n    }\n\n    return this.row;\n  }\n  /* eslint no-unused-vars: [\"error\", { \"argsIgnorePattern\": \"^_\" }] */\n\n\n  row(packet, _connection) {\n    if (packet.isEOF()) {\n      const status = packet.eofStatusFlags();\n      const moreResults = status & ServerStatus.SERVER_MORE_RESULTS_EXISTS;\n\n      if (moreResults) {\n        this._resultIndex++;\n        return Query.prototype.resultsetHeader;\n      }\n\n      return this.done();\n    }\n\n    let row;\n\n    try {\n      row = this._rowParser.next(packet, this._fields[this._resultIndex], this.options);\n    } catch (err) {\n      this._localStreamError = err;\n      return this.doneInsert(null);\n    }\n\n    if (this.onResult) {\n      this._rows[this._resultIndex].push(row);\n    } else {\n      this.emit('result', row);\n    }\n\n    return Query.prototype.row;\n  }\n\n  infileOk(packet, connection) {\n    const rs = new Packets.ResultSetHeader(packet, connection);\n    return this.doneInsert(rs);\n  }\n\n  stream(options) {\n    options = options || {};\n    options.objectMode = true;\n    const stream = new Readable(options);\n\n    stream._read = () => {\n      this._connection && this._connection.resume();\n    };\n\n    this.on('result', row => {\n      if (!stream.push(row)) {\n        this._connection.pause();\n      }\n\n      stream.emit('result', row); // replicate old emitter\n    });\n    this.on('error', err => {\n      stream.emit('error', err); // Pass on any errors\n    });\n    this.on('end', () => {\n      stream.push(null); // pushing null, indicating EOF\n\n      stream.emit('close'); // notify readers that query has completed\n    });\n    this.on('fields', fields => {\n      stream.emit('fields', fields); // replicate old emitter\n    });\n    return stream;\n  }\n\n  _setTimeout() {\n    if (this.timeout) {\n      const timeoutHandler = this._handleTimeoutError.bind(this);\n\n      this.queryTimeout = Timers.setTimeout(timeoutHandler, this.timeout);\n    }\n  }\n\n  _handleTimeoutError() {\n    if (this.queryTimeout) {\n      Timers.clearTimeout(this.queryTimeout);\n      this.queryTimeout = null;\n    }\n\n    const err = new Error('Query inactivity timeout');\n    err.errorno = 'PROTOCOL_SEQUENCE_TIMEOUT';\n    err.code = 'PROTOCOL_SEQUENCE_TIMEOUT';\n    err.syscall = 'query';\n\n    if (this.onResult) {\n      this.onResult(err);\n    } else {\n      this.emit('error', err);\n    }\n  }\n\n}\n\nQuery.prototype.catch = Query.prototype.then;\nmodule.exports = Query;","map":{"version":3,"sources":["C:/Users/jayes/Downloads/react-hook-form-crud-example/src/_helpers/node_modules/mysql2/lib/commands/query.js"],"names":["process","require","Timers","Readable","Command","Packets","getTextParser","ServerStatus","EmptyPacket","Packet","Buffer","allocUnsafe","Query","constructor","options","callback","sql","values","_queryOptions","namedPlaceholders","onResult","timeout","queryTimeout","_fieldCount","_rowParser","_fields","_rows","_receivedFieldsCount","_resultIndex","_localStream","_unpipeStream","_streamFactory","infileStreamFactory","_connection","then","err","console","log","Error","start","_packet","connection","config","debug","Object","assign","_setTimeout","cmdPacket","charsetNumber","writePacket","toPacket","prototype","resultsetHeader","done","clearTimeout","rows","fields","nextTick","doneInsert","rs","_localStreamError","emit","push","serverStatus","SERVER_MORE_RESULTS_EXISTS","packet","ResultSetHeader","fieldCount","_streamLocalInfile","infileName","readField","path","infileOk","onConnectionError","onDrain","resume","onPause","pause","onData","data","dataWithHeader","length","copy","onEnd","removeListener","onError","stream","on","once","field","ColumnDefinition","clientEncoding","name","columnType","flags","fieldsEOF","isEOF","protocolError","row","status","eofStatusFlags","moreResults","next","objectMode","_read","timeoutHandler","_handleTimeoutError","bind","setTimeout","errorno","code","syscall","catch","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst process = require('process');\nconst Timers = require('timers');\n\nconst Readable = require('stream').Readable;\n\nconst Command = require('./command.js');\nconst Packets = require('../packets/index.js');\nconst getTextParser = require('../parsers/text_parser.js');\nconst ServerStatus = require('../constants/server_status.js');\n\nconst EmptyPacket = new Packets.Packet(0, Buffer.allocUnsafe(4), 0, 4);\n\n// http://dev.mysql.com/doc/internals/en/com-query.html\nclass Query extends Command {\n  constructor(options, callback) {\n    super();\n    this.sql = options.sql;\n    this.values = options.values;\n    this._queryOptions = options;\n    this.namedPlaceholders = options.namedPlaceholders || false;\n    this.onResult = callback;\n    this.timeout = options.timeout;\n    this.queryTimeout = null;\n    this._fieldCount = 0;\n    this._rowParser = null;\n    this._fields = [];\n    this._rows = [];\n    this._receivedFieldsCount = 0;\n    this._resultIndex = 0;\n    this._localStream = null;\n    this._unpipeStream = function() {};\n    this._streamFactory = options.infileStreamFactory;\n    this._connection = null;\n  }\n\n  then() {\n    const err =\n      \"You have tried to call .then(), .catch(), or invoked await on the result of query that is not a promise, which is a programming error. Try calling con.promise().query(), or require('mysql2/promise') instead of 'mysql2' for a promise-compatible version of the query interface. To learn how to use async/await or Promises check out documentation at https://www.npmjs.com/package/mysql2#using-promise-wrapper, or the mysql2 documentation at https://github.com/sidorares/node-mysql2/tree/master/documentation/Promise-Wrapper.md\";\n    // eslint-disable-next-line\n    console.log(err);\n    throw new Error(err);\n  }\n\n  /* eslint no-unused-vars: [\"error\", { \"argsIgnorePattern\": \"^_\" }] */\n  start(_packet, connection) {\n    if (connection.config.debug) {\n      // eslint-disable-next-line\n      console.log('        Sending query command: %s', this.sql);\n    }\n    this._connection = connection;\n    this.options = Object.assign({}, connection.config, this._queryOptions);\n    this._setTimeout();\n\n    const cmdPacket = new Packets.Query(\n      this.sql,\n      connection.config.charsetNumber\n    );\n    connection.writePacket(cmdPacket.toPacket(1));\n    return Query.prototype.resultsetHeader;\n  }\n\n  done() {\n    this._unpipeStream();\n    // if all ready timeout, return null directly\n    if (this.timeout && !this.queryTimeout) {\n      return null;\n    }\n    // else clear timer\n    if (this.queryTimeout) {\n      Timers.clearTimeout(this.queryTimeout);\n      this.queryTimeout = null;\n    }\n    if (this.onResult) {\n      let rows, fields;\n      if (this._resultIndex === 0) {\n        rows = this._rows[0];\n        fields = this._fields[0];\n      } else {\n        rows = this._rows;\n        fields = this._fields;\n      }\n      if (fields) {\n        process.nextTick(() => {\n          this.onResult(null, rows, fields);\n        });\n      } else {\n        process.nextTick(() => {\n          this.onResult(null, rows);\n        });\n      }\n    }\n    return null;\n  }\n\n  doneInsert(rs) {\n    if (this._localStreamError) {\n      if (this.onResult) {\n        this.onResult(this._localStreamError, rs);\n      } else {\n        this.emit('error', this._localStreamError);\n      }\n      return null;\n    }\n    this._rows.push(rs);\n    this._fields.push(void 0);\n    this.emit('fields', void 0);\n    this.emit('result', rs);\n    if (rs.serverStatus & ServerStatus.SERVER_MORE_RESULTS_EXISTS) {\n      this._resultIndex++;\n      return this.resultsetHeader;\n    }\n    return this.done();\n  }\n\n  resultsetHeader(packet, connection) {\n    const rs = new Packets.ResultSetHeader(packet, connection);\n    this._fieldCount = rs.fieldCount;\n    if (connection.config.debug) {\n      // eslint-disable-next-line\n      console.log(\n        `        Resultset header received, expecting ${rs.fieldCount} column definition packets`\n      );\n    }\n    if (this._fieldCount === 0) {\n      return this.doneInsert(rs);\n    }\n    if (this._fieldCount === null) {\n      return this._streamLocalInfile(connection, rs.infileName);\n    }\n    this._receivedFieldsCount = 0;\n    this._rows.push([]);\n    this._fields.push([]);\n    return this.readField;\n  }\n\n  _streamLocalInfile(connection, path) {\n    if (this._streamFactory) {\n      this._localStream = this._streamFactory(path);\n    } else {\n      this._localStreamError = new Error(\n        `As a result of LOCAL INFILE command server wants to read ${path} file, but as of v2.0 you must provide streamFactory option returning ReadStream.`\n      );\n      connection.writePacket(EmptyPacket);\n      return this.infileOk;\n    }\n\n    const onConnectionError = () => {\n      this._unpipeStream();\n    };\n    const onDrain = () => {\n      this._localStream.resume();\n    };\n    const onPause = () => {\n      this._localStream.pause();\n    };\n    const onData = function(data) {\n      const dataWithHeader = Buffer.allocUnsafe(data.length + 4);\n      data.copy(dataWithHeader, 4);\n      connection.writePacket(\n        new Packets.Packet(0, dataWithHeader, 0, dataWithHeader.length)\n      );\n    };\n    const onEnd = () => {\n      connection.removeListener('error', onConnectionError);\n      connection.writePacket(EmptyPacket);\n    };\n    const onError = err => {\n      this._localStreamError = err;\n      connection.removeListener('error', onConnectionError);\n      connection.writePacket(EmptyPacket);\n    };\n    this._unpipeStream = () => {\n      connection.stream.removeListener('pause', onPause);\n      connection.stream.removeListener('drain', onDrain);\n      this._localStream.removeListener('data', onData);\n      this._localStream.removeListener('end', onEnd);\n      this._localStream.removeListener('error', onError);\n    };\n    connection.stream.on('pause', onPause);\n    connection.stream.on('drain', onDrain);\n    this._localStream.on('data', onData);\n    this._localStream.on('end', onEnd);\n    this._localStream.on('error', onError);\n    connection.once('error', onConnectionError);\n    return this.infileOk;\n  }\n\n  readField(packet, connection) {\n    this._receivedFieldsCount++;\n    // Often there is much more data in the column definition than in the row itself\n    // If you set manually _fields[0] to array of ColumnDefinition's (from previous call)\n    // you can 'cache' result of parsing. Field packets still received, but ignored in that case\n    // this is the reason _receivedFieldsCount exist (otherwise we could just use current length of fields array)\n    if (this._fields[this._resultIndex].length !== this._fieldCount) {\n      const field = new Packets.ColumnDefinition(\n        packet,\n        connection.clientEncoding\n      );\n      this._fields[this._resultIndex].push(field);\n      if (connection.config.debug) {\n        /* eslint-disable no-console */\n        console.log('        Column definition:');\n        console.log(`          name: ${field.name}`);\n        console.log(`          type: ${field.columnType}`);\n        console.log(`         flags: ${field.flags}`);\n        /* eslint-enable no-console */\n      }\n    }\n    // last field received\n    if (this._receivedFieldsCount === this._fieldCount) {\n      const fields = this._fields[this._resultIndex];\n      this.emit('fields', fields);\n      this._rowParser = new (getTextParser(fields, this.options, connection.config))();\n      return Query.prototype.fieldsEOF;\n    }\n    return Query.prototype.readField;\n  }\n\n  fieldsEOF(packet, connection) {\n    // check EOF\n    if (!packet.isEOF()) {\n      return connection.protocolError('Expected EOF packet');\n    }\n    return this.row;\n  }\n\n  /* eslint no-unused-vars: [\"error\", { \"argsIgnorePattern\": \"^_\" }] */\n  row(packet, _connection) { \n    if (packet.isEOF()) {\n      const status = packet.eofStatusFlags();\n      const moreResults = status & ServerStatus.SERVER_MORE_RESULTS_EXISTS;\n      if (moreResults) {\n        this._resultIndex++;\n        return Query.prototype.resultsetHeader;\n      }\n      return this.done();\n    }\n    let row;\n    try {\n      row = this._rowParser.next(\n        packet,\n        this._fields[this._resultIndex],\n        this.options\n      );\n    } catch (err) {\n      this._localStreamError = err;\n      return this.doneInsert(null);\n    }\n    if (this.onResult) {\n      this._rows[this._resultIndex].push(row);\n    } else {\n      this.emit('result', row);\n    }\n    return Query.prototype.row;\n  }\n\n  infileOk(packet, connection) {\n    const rs = new Packets.ResultSetHeader(packet, connection);\n    return this.doneInsert(rs);\n  }\n\n  stream(options) {\n    options = options || {};\n    options.objectMode = true;\n    const stream = new Readable(options);\n    stream._read = () => {\n      this._connection && this._connection.resume();\n    };\n    this.on('result', row => {\n      if (!stream.push(row)) {\n        this._connection.pause();\n      }\n      stream.emit('result', row); // replicate old emitter\n    });\n    this.on('error', err => {\n      stream.emit('error', err); // Pass on any errors\n    });\n    this.on('end', () => {\n      stream.push(null); // pushing null, indicating EOF\n      stream.emit('close'); // notify readers that query has completed\n    });\n    this.on('fields', fields => {\n      stream.emit('fields', fields); // replicate old emitter\n    });\n    return stream;\n  }\n\n  _setTimeout() {\n    if (this.timeout) {\n      const timeoutHandler = this._handleTimeoutError.bind(this);\n      this.queryTimeout = Timers.setTimeout(\n        timeoutHandler,\n        this.timeout\n      );\n    }\n  }\n\n  _handleTimeoutError() {\n    if (this.queryTimeout) {\n      Timers.clearTimeout(this.queryTimeout);\n      this.queryTimeout = null;\n    }\n    \n    const err = new Error('Query inactivity timeout');\n    err.errorno = 'PROTOCOL_SEQUENCE_TIMEOUT';\n    err.code = 'PROTOCOL_SEQUENCE_TIMEOUT';\n    err.syscall = 'query';\n\n    if (this.onResult) {\n      this.onResult(err);\n    } else {\n      this.emit('error', err);\n    }\n  }\n}\n\nQuery.prototype.catch = Query.prototype.then;\n\nmodule.exports = Query;\n"]},"metadata":{},"sourceType":"module"}