{"ast":null,"code":"'use strict';\n\nconst process = require('process');\n\nconst Pool = require('./pool.js');\n\nconst PoolConfig = require('./pool_config.js');\n\nconst Connection = require('./connection.js');\n\nconst EventEmitter = require('events').EventEmitter;\n/**\n * Selector\n */\n\n\nconst makeSelector = {\n  RR() {\n    let index = 0;\n    return clusterIds => clusterIds[index++ % clusterIds.length];\n  },\n\n  RANDOM() {\n    return clusterIds => clusterIds[Math.floor(Math.random() * clusterIds.length)];\n  },\n\n  ORDER() {\n    return clusterIds => clusterIds[0];\n  }\n\n};\n\nclass PoolNamespace {\n  constructor(cluster, pattern, selector) {\n    this._cluster = cluster;\n    this._pattern = pattern;\n    this._selector = makeSelector[selector]();\n  }\n\n  getConnection(cb) {\n    const clusterNode = this._getClusterNode();\n\n    if (clusterNode === null) {\n      return cb(new Error('Pool does Not exists.'));\n    }\n\n    return this._cluster._getConnection(clusterNode, (err, connection) => {\n      if (err) {\n        return cb(err);\n      }\n\n      if (connection === 'retry') {\n        return this.getConnection(cb);\n      }\n\n      return cb(null, connection);\n    });\n  }\n  /**\n   * pool cluster query\n   * @param {*} sql\n   * @param {*} values\n   * @param {*} cb\n   * @returns query\n   */\n\n\n  query(sql, values, cb) {\n    const query = Connection.createQuery(sql, values, cb, {});\n    this.getConnection((err, conn) => {\n      if (err) {\n        if (typeof query.onResult === 'function') {\n          query.onResult(err);\n        } else {\n          query.emit('error', err);\n        }\n\n        return;\n      }\n\n      try {\n        conn.query(query).once('end', () => {\n          conn.release();\n        });\n      } catch (e) {\n        conn.release();\n        throw e;\n      }\n    });\n    return query;\n  }\n  /**\n   * pool cluster execute\n   * @param {*} sql \n   * @param {*} values \n   * @param {*} cb \n   */\n\n\n  execute(sql, values, cb) {\n    if (typeof values === 'function') {\n      cb = values;\n      values = [];\n    }\n\n    this.getConnection((err, conn) => {\n      if (err) {\n        return cb(err);\n      }\n\n      try {\n        conn.execute(sql, values, cb).once('end', () => {\n          conn.release();\n        });\n      } catch (e) {\n        conn.release();\n        throw e;\n      }\n    });\n  }\n\n  _getClusterNode() {\n    const foundNodeIds = this._cluster._findNodeIds(this._pattern);\n\n    if (foundNodeIds.length === 0) {\n      return null;\n    }\n\n    const nodeId = foundNodeIds.length === 1 ? foundNodeIds[0] : this._selector(foundNodeIds);\n    return this._cluster._getNode(nodeId);\n  }\n\n}\n\nclass PoolCluster extends EventEmitter {\n  constructor(config) {\n    super();\n    config = config || {};\n    this._canRetry = typeof config.canRetry === 'undefined' ? true : config.canRetry;\n    this._removeNodeErrorCount = config.removeNodeErrorCount || 5;\n    this._defaultSelector = config.defaultSelector || 'RR';\n    this._closed = false;\n    this._lastId = 0;\n    this._nodes = {};\n    this._serviceableNodeIds = [];\n    this._namespaces = {};\n    this._findCaches = {};\n  }\n\n  of(pattern, selector) {\n    pattern = pattern || '*';\n    selector = selector || this._defaultSelector;\n    selector = selector.toUpperCase();\n\n    if (!makeSelector[selector] === 'undefined') {\n      selector = this._defaultSelector;\n    }\n\n    const key = pattern + selector;\n\n    if (typeof this._namespaces[key] === 'undefined') {\n      this._namespaces[key] = new PoolNamespace(this, pattern, selector);\n    }\n\n    return this._namespaces[key];\n  }\n\n  add(id, config) {\n    if (typeof id === 'object') {\n      config = id;\n      id = `CLUSTER::${++this._lastId}`;\n    }\n\n    if (typeof this._nodes[id] === 'undefined') {\n      this._nodes[id] = {\n        id: id,\n        errorCount: 0,\n        pool: new Pool({\n          config: new PoolConfig(config)\n        })\n      };\n\n      this._serviceableNodeIds.push(id);\n\n      this._clearFindCaches();\n    }\n  }\n\n  getConnection(pattern, selector, cb) {\n    let namespace;\n\n    if (typeof pattern === 'function') {\n      cb = pattern;\n      namespace = this.of();\n    } else {\n      if (typeof selector === 'function') {\n        cb = selector;\n        selector = this._defaultSelector;\n      }\n\n      namespace = this.of(pattern, selector);\n    }\n\n    namespace.getConnection(cb);\n  }\n\n  end(callback) {\n    const cb = callback !== undefined ? callback : err => {\n      if (err) {\n        throw err;\n      }\n    };\n\n    if (this._closed) {\n      process.nextTick(cb);\n      return;\n    }\n\n    this._closed = true;\n    let calledBack = false;\n    let waitingClose = 0;\n\n    const onEnd = err => {\n      if (!calledBack && (err || --waitingClose <= 0)) {\n        calledBack = true;\n        return cb(err);\n      }\n    };\n\n    for (const id in this._nodes) {\n      waitingClose++;\n\n      this._nodes[id].pool.end(onEnd);\n    }\n\n    if (waitingClose === 0) {\n      process.nextTick(onEnd);\n    }\n  }\n\n  _findNodeIds(pattern) {\n    if (typeof this._findCaches[pattern] !== 'undefined') {\n      return this._findCaches[pattern];\n    }\n\n    let foundNodeIds;\n\n    if (pattern === '*') {\n      // all\n      foundNodeIds = this._serviceableNodeIds;\n    } else if (this._serviceableNodeIds.indexOf(pattern) !== -1) {\n      // one\n      foundNodeIds = [pattern];\n    } else {\n      // wild matching\n      const keyword = pattern.substring(pattern.length - 1, 0);\n      foundNodeIds = this._serviceableNodeIds.filter(id => id.startsWith(keyword));\n    }\n\n    this._findCaches[pattern] = foundNodeIds;\n    return foundNodeIds;\n  }\n\n  _getNode(id) {\n    return this._nodes[id] || null;\n  }\n\n  _increaseErrorCount(node) {\n    if (++node.errorCount >= this._removeNodeErrorCount) {\n      const index = this._serviceableNodeIds.indexOf(node.id);\n\n      if (index !== -1) {\n        this._serviceableNodeIds.splice(index, 1);\n\n        delete this._nodes[node.id];\n\n        this._clearFindCaches();\n\n        node.pool.end();\n        this.emit('remove', node.id);\n      }\n    }\n  }\n\n  _decreaseErrorCount(node) {\n    if (node.errorCount > 0) {\n      --node.errorCount;\n    }\n  }\n\n  _getConnection(node, cb) {\n    node.pool.getConnection((err, connection) => {\n      if (err) {\n        this._increaseErrorCount(node);\n\n        if (this._canRetry) {\n          // REVIEW: this seems wrong?\n          this.emit('warn', err); // eslint-disable-next-line no-console\n\n          console.warn(`[Error] PoolCluster : ${err}`);\n          return cb(null, 'retry');\n        }\n\n        return cb(err);\n      }\n\n      this._decreaseErrorCount(node);\n\n      connection._clusterId = node.id;\n      return cb(null, connection);\n    });\n  }\n\n  _clearFindCaches() {\n    this._findCaches = {};\n  }\n\n}\n\nmodule.exports = PoolCluster;","map":{"version":3,"sources":["C:/Users/jayes/Downloads/react-hook-form-crud-example/src/_helpers/node_modules/mysql2/lib/pool_cluster.js"],"names":["process","require","Pool","PoolConfig","Connection","EventEmitter","makeSelector","RR","index","clusterIds","length","RANDOM","Math","floor","random","ORDER","PoolNamespace","constructor","cluster","pattern","selector","_cluster","_pattern","_selector","getConnection","cb","clusterNode","_getClusterNode","Error","_getConnection","err","connection","query","sql","values","createQuery","conn","onResult","emit","once","release","e","execute","foundNodeIds","_findNodeIds","nodeId","_getNode","PoolCluster","config","_canRetry","canRetry","_removeNodeErrorCount","removeNodeErrorCount","_defaultSelector","defaultSelector","_closed","_lastId","_nodes","_serviceableNodeIds","_namespaces","_findCaches","of","toUpperCase","key","add","id","errorCount","pool","push","_clearFindCaches","namespace","end","callback","undefined","nextTick","calledBack","waitingClose","onEnd","indexOf","keyword","substring","filter","startsWith","_increaseErrorCount","node","splice","_decreaseErrorCount","console","warn","_clusterId","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst process = require('process');\n\nconst Pool = require('./pool.js');\nconst PoolConfig = require('./pool_config.js');\nconst Connection = require('./connection.js');\nconst EventEmitter = require('events').EventEmitter;\n\n/**\n * Selector\n */\nconst makeSelector = {\n  RR() {\n    let index = 0;\n    return clusterIds => clusterIds[index++ % clusterIds.length];\n  },\n  RANDOM() {\n    return clusterIds =>\n      clusterIds[Math.floor(Math.random() * clusterIds.length)];\n  },\n  ORDER() {\n    return clusterIds => clusterIds[0];\n  }\n};\n\nclass PoolNamespace {\n  constructor(cluster, pattern, selector) {\n    this._cluster = cluster;\n    this._pattern = pattern;\n    this._selector = makeSelector[selector]();\n  }\n\n  getConnection(cb) {\n    const clusterNode = this._getClusterNode();\n    if (clusterNode === null) {\n      return cb(new Error('Pool does Not exists.'));\n    }\n    return this._cluster._getConnection(clusterNode, (err, connection) => {\n      if (err) {\n        return cb(err);\n      }\n      if (connection === 'retry') {\n        return this.getConnection(cb);\n      }\n      return cb(null, connection);\n    });\n  }\n\n  /**\n   * pool cluster query\n   * @param {*} sql\n   * @param {*} values\n   * @param {*} cb\n   * @returns query\n   */\n  query(sql, values, cb) {\n    const query = Connection.createQuery(sql, values, cb, {});\n    this.getConnection((err, conn) => {\n      if (err) {\n        if (typeof query.onResult === 'function') {\n          query.onResult(err);\n        } else {\n          query.emit('error', err);\n        }\n        return;\n      }\n      try {\n        conn.query(query).once('end', () => {\n          conn.release();\n        });\n      } catch (e) {\n        conn.release();\n        throw e;\n      }\n    });\n    return query;\n  }\n\n  /**\n   * pool cluster execute\n   * @param {*} sql \n   * @param {*} values \n   * @param {*} cb \n   */\n  execute(sql, values, cb) {\n    if (typeof values === 'function') {\n      cb = values;\n      values = [];\n    }\n    this.getConnection((err, conn) => {\n      if (err) {\n        return cb(err);\n      }\n      try {\n        conn.execute(sql, values, cb).once('end', () => {\n          conn.release();\n        });\n      } catch (e) {\n        conn.release();\n        throw e;\n      }\n    });\n  }\n\n  _getClusterNode() {\n    const foundNodeIds = this._cluster._findNodeIds(this._pattern);\n    if (foundNodeIds.length === 0) {\n      return null;\n    }\n    const nodeId =\n      foundNodeIds.length === 1\n        ? foundNodeIds[0]\n        : this._selector(foundNodeIds);\n    return this._cluster._getNode(nodeId);\n  }\n}\n\nclass PoolCluster extends EventEmitter {\n  constructor(config) {\n    super();\n    config = config || {};\n    this._canRetry =\n      typeof config.canRetry === 'undefined' ? true : config.canRetry;\n    this._removeNodeErrorCount = config.removeNodeErrorCount || 5;\n    this._defaultSelector = config.defaultSelector || 'RR';\n    this._closed = false;\n    this._lastId = 0;\n    this._nodes = {};\n    this._serviceableNodeIds = [];\n    this._namespaces = {};\n    this._findCaches = {};\n  }\n\n  of(pattern, selector) {\n    pattern = pattern || '*';\n    selector = selector || this._defaultSelector;\n    selector = selector.toUpperCase();\n    if (!makeSelector[selector] === 'undefined') {\n      selector = this._defaultSelector;\n    }\n    const key = pattern + selector;\n    if (typeof this._namespaces[key] === 'undefined') {\n      this._namespaces[key] = new PoolNamespace(this, pattern, selector);\n    }\n    return this._namespaces[key];\n  }\n\n  add(id, config) {\n    if (typeof id === 'object') {\n      config = id;\n      id = `CLUSTER::${++this._lastId}`;\n    }\n    if (typeof this._nodes[id] === 'undefined') {\n      this._nodes[id] = {\n        id: id,\n        errorCount: 0,\n        pool: new Pool({ config: new PoolConfig(config) })\n      };\n      this._serviceableNodeIds.push(id);\n      this._clearFindCaches();\n    }\n  }\n\n  getConnection(pattern, selector, cb) {\n    let namespace;\n    if (typeof pattern === 'function') {\n      cb = pattern;\n      namespace = this.of();\n    } else {\n      if (typeof selector === 'function') {\n        cb = selector;\n        selector = this._defaultSelector;\n      }\n      namespace = this.of(pattern, selector);\n    }\n    namespace.getConnection(cb);\n  }\n\n  end(callback) {\n    const cb =\n      callback !== undefined\n        ? callback\n        : err => {\n          if (err) {\n            throw err;\n          }\n        };\n    if (this._closed) {\n      process.nextTick(cb);\n      return;\n    }\n    this._closed = true;\n\n    let calledBack = false;\n    let waitingClose = 0;\n    const onEnd = err => {\n      if (!calledBack && (err || --waitingClose <= 0)) {\n        calledBack = true;\n        return cb(err);\n      }\n    };\n\n    for (const id in this._nodes) {\n      waitingClose++;\n      this._nodes[id].pool.end(onEnd);\n    }\n    if (waitingClose === 0) {\n      process.nextTick(onEnd);\n    }\n  }\n\n  _findNodeIds(pattern) {\n    if (typeof this._findCaches[pattern] !== 'undefined') {\n      return this._findCaches[pattern];\n    }\n    let foundNodeIds;\n    if (pattern === '*') {\n      // all\n      foundNodeIds = this._serviceableNodeIds;\n    } else if (this._serviceableNodeIds.indexOf(pattern) !== -1) {\n      // one\n      foundNodeIds = [pattern];\n    } else {\n      // wild matching\n      const keyword = pattern.substring(pattern.length - 1, 0);\n      foundNodeIds = this._serviceableNodeIds.filter(id =>\n        id.startsWith(keyword)\n      );\n    }\n    this._findCaches[pattern] = foundNodeIds;\n    return foundNodeIds;\n  }\n\n  _getNode(id) {\n    return this._nodes[id] || null;\n  }\n\n  _increaseErrorCount(node) {\n    if (++node.errorCount >= this._removeNodeErrorCount) {\n      const index = this._serviceableNodeIds.indexOf(node.id);\n      if (index !== -1) {\n        this._serviceableNodeIds.splice(index, 1);\n        delete this._nodes[node.id];\n        this._clearFindCaches();\n        node.pool.end();\n        this.emit('remove', node.id);\n      }\n    }\n  }\n\n  _decreaseErrorCount(node) {\n    if (node.errorCount > 0) {\n      --node.errorCount;\n    }\n  }\n\n  _getConnection(node, cb) {\n    node.pool.getConnection((err, connection) => {\n      if (err) {\n        this._increaseErrorCount(node);\n        if (this._canRetry) {\n          // REVIEW: this seems wrong?\n          this.emit('warn', err);\n          // eslint-disable-next-line no-console\n          console.warn(`[Error] PoolCluster : ${err}`);\n          return cb(null, 'retry');\n        }\n        return cb(err);\n      }\n      this._decreaseErrorCount(node);\n\n      connection._clusterId = node.id;\n      return cb(null, connection);\n    });\n  }\n\n  _clearFindCaches() {\n    this._findCaches = {};\n  }\n}\n\nmodule.exports = PoolCluster;\n"]},"metadata":{},"sourceType":"module"}