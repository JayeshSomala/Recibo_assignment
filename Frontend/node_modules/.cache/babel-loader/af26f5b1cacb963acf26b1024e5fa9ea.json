{"ast":null,"code":"import { transformToNestObject as e } from \"react-hook-form\";\n\nfunction r() {\n  return (r = Object.assign || function (e) {\n    for (var r = 1; r < arguments.length; r++) {\n      var t = arguments[r];\n\n      for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);\n    }\n\n    return e;\n  }).apply(this, arguments);\n}\n\nvar t = function (t, n) {\n  return void 0 === n && (n = {\n    abortEarly: !1\n  }), function (o, a, s) {\n    void 0 === s && (s = !1);\n\n    try {\n      return Promise.resolve(function (e, s) {\n        try {\n          var c = (n.context && \"development\" === process.env.NODE_ENV && console.warn(\"You should not used the yup options context. Please, use the 'useForm' context object instead\"), Promise.resolve(t.validate(o, r({}, n, {\n            context: a\n          }))).then(function (e) {\n            return {\n              values: e,\n              errors: {}\n            };\n          }));\n        } catch (e) {\n          return s(e);\n        }\n\n        return c && c.then ? c.then(void 0, s) : c;\n      }(0, function (t) {\n        if (!t.inner) throw t;\n\n        var n = function (e, t) {\n          var n;\n          return Array.isArray(e.inner) && e.inner.length ? e.inner.reduce(function (e, n) {\n            var o,\n                a,\n                s = n.path,\n                c = n.message,\n                u = n.type,\n                i = e[s] && e[s].types || {},\n                p = s || u;\n            return r({}, e, p ? ((a = {})[p] = r({}, e[p] || {\n              message: c,\n              type: u\n            }, t ? {\n              types: r({}, i, (o = {}, o[u] = i[u] ? [].concat([].concat(i[u]), [c]) : c, o))\n            } : {}), a) : {});\n          }, {}) : ((n = {})[e.path] = {\n            message: e.message,\n            type: e.type\n          }, n);\n        }(t, s);\n\n        return {\n          values: {},\n          errors: e(n)\n        };\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n};\n\nexport { t as yupResolver };","map":{"version":3,"mappings":";;;;;;;;;;;;AAWA;;AAAA,IAiDaA,IAAc,UACzBC,CADyB,EAEzBC,CAFyB,EAEzBA;AAAAA,8BAAgD;AAC9CC,iBAAY;AADkC,GAAhDD,GACc,UAGdE,CAHc,EAIdC,CAJc,EAKdC,CALc,EAKdA;AAAAA,0BAA2B,CAA3BA;;AAA2B;AAAA;AAAA;AAAA,mBAGrBJ,EAAQG,OAARH,IAA4C,kBAAzBK,QAAQC,GAARD,CAAYE,QAA/BP,IAEFQ,QAAQC,IAARD,CACE,+FADFA,CAFER,EAGAU,gBAIYX,EAAOY,QAAPZ,CAAgBG,CAAhBH,EAAgBG,MACzBF,CADyBE,EACzBF;AACHG;AADGH,WADyBE,CAAhBH,CAJZ,EAMAI,IANA,CAMAA;AAHJ,mBAAO;AACLD,uBADK;AAKLU,sBAAQ;AALH,aAAP;AAKU,WARN,CANqB;AAcf,SAde,CAcf;AAAA;AAAA;;AAAA;AAAA,OAde,CAcf,CAde,EAcf,UAEHC,CAFG,EAEHA;AACP,aAAKA,EAAEC,KAAP,EACE,MAAMD,CAAN;;AAGF,YAAME,IA9Ee,UACvBC,CADuB,EAEvBZ,CAFuB,EAEvBA;AAAAA;AAEA,iBAAOa,MAAMC,OAAND,CAAcD,EAAMF,KAApBG,KAA8BD,EAAMF,KAANE,CAAYG,MAA1CF,GACHD,EAAMF,KAANE,CAAYI,MAAZJ,CACE,UAACK,CAAD,EAACA,CAAD,EAACA;AAAAA;AAAAA;AAAAA,gBAAiCC,UAAjCD;AAAAA,gBAAuCE,aAAvCF;AAAAA,gBAAgDG,UAAhDH;AAAAA,gBAEOI,IAAiBJ,EAASC,CAATD,KAAkBA,EAASC,CAATD,EAAeK,KAAjCL,IAA2C,EAFnEA;AAAAA,gBAGOM,IAAML,KAAQE,CAHrBH;AAKC,yBACKA,CADL,EAEMM,cAEGA,CAFHA,IAEGA,MACKN,EAASM,CAATN,KAAiB;AACnBE,wBADmB;AAEnBC;AAFmB,aADtBG,EAKKvB,IACA;AACEsB,2BACKD,CADLC,GACKD,UAEFD,CAFEC,IAEKA,EAAcD,CAAdC,IAAcD,UAEd,GAAGI,MAAH,CAAUH,EAAcD,CAAdC,CAAV,CAFcD,EAEUA,CAAQD,CAARC,CAFVA,CAAdC,GAGJF,CALDE,EAKCF,CANNG;AADF,aADAtB,GAWA,EAhBLuB,CAFHA,EAkBQE,CAlBRF,IAqBA,EAvBN;AAuBM,WA7BVX,EAgCE,EAhCFA,CADGC,IAiCD,SAICD,EAAMM,IAJP,IAIc;AAAEC,qBAASP,EAAMO,OAAjB;AAA0BC,kBAAMR,EAAMQ;AAAtC,WAJd,EAIoDA,CArCnDP,CAAP;AA0EuBa,SA9EA,CA8EiBjB,CA9EjB,EA8EoBT,CA9EpB,CA8ErB;;AACA,eAAO;AACLF,kBAAQ,EADH;AAELU,kBAAQmB,EAAsBhB,CAAtBgB;AAFH,SAAP;AAEgChB,OAxBP;AARF,KAQE,CARF;AAAA;AAAA;AAAA,GAEzBf;AAFyB,CAjD3B;;AAiD2B","names":["yupResolver","schema","options","abortEarly","values","context","validateAllFieldCriteria","process","env","NODE_ENV","console","warn","Promise","validate","errors","e","inner","parsedErrors","error","Array","isArray","length","reduce","previous","path","message","type","previousTypes","types","key","concat","a","parseErrorSchema","transformToNestObject"],"sources":["C:\\Users\\jayes\\OneDrive\\Desktop\\Recibo\\Assignment\\Frontend\\node_modules\\@hookform\\resolvers\\yup\\src\\yup.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/ban-ts-comment */\nimport { Resolver, transformToNestObject, FieldValues } from 'react-hook-form';\nimport Yup from 'yup';\nimport Lazy from 'yup/lib/Lazy';\n\n/**\n * From 0.32.0, Yup add TypeScript support and `path` typing is optional that's why we have `@ts-expect-error`\n * FYI: `path`: a string, indicating where there error was thrown. `path` is empty at the root level.\n * react-hook-form's values are object so path is defined\n * https://github.com/jquense/yup#validationerrorerrors-string--arraystring-value-any-path-string\n */\nconst parseErrorSchema = (\n  error: Yup.ValidationError,\n  validateAllFieldCriteria: boolean,\n) => {\n  return Array.isArray(error.inner) && error.inner.length\n    ? error.inner.reduce(\n        (previous: Record<string, any>, { path, message, type }) => {\n          // @ts-expect-error\n          const previousTypes = (previous[path] && previous[path].types) || {};\n          const key = path || type;\n\n          return {\n            ...previous,\n            ...(key\n              ? {\n                  [key]: {\n                    ...(previous[key] || {\n                      message,\n                      type,\n                    }),\n                    ...(validateAllFieldCriteria\n                      ? {\n                          types: {\n                            ...previousTypes,\n                            // @ts-expect-error\n                            [type]: previousTypes[type]\n                              ? // @ts-expect-error\n                                [...[].concat(previousTypes[type]), message]\n                              : message,\n                          },\n                        }\n                      : {}),\n                  },\n                }\n              : {}),\n          };\n        },\n        {},\n      )\n    : {\n        // @ts-expect-error\n        [error.path]: { message: error.message, type: error.type },\n      };\n};\n\ntype ValidateOptions<T extends Yup.AnyObjectSchema> = Parameters<\n  T['validate']\n>[1];\n\nexport const yupResolver = <TFieldValues extends FieldValues>(\n  schema: Yup.AnyObjectSchema | Lazy<any, any>,\n  options: ValidateOptions<Yup.AnyObjectSchema> = {\n    abortEarly: false,\n  },\n): Resolver<TFieldValues> => async (\n  values,\n  context,\n  validateAllFieldCriteria = false,\n) => {\n  try {\n    if (options.context && process.env.NODE_ENV === 'development') {\n      // eslint-disable-next-line no-console\n      console.warn(\n        \"You should not used the yup options context. Please, use the 'useForm' context object instead\",\n      );\n    }\n    return {\n      values: await schema.validate(values, {\n        ...options,\n        context,\n      }),\n      errors: {},\n    };\n  } catch (e: any) {\n    if (!e.inner) {\n      throw e;\n    }\n\n    const parsedErrors = parseErrorSchema(e, validateAllFieldCriteria);\n    return {\n      values: {},\n      errors: transformToNestObject(parsedErrors),\n    };\n  }\n};\n"]},"metadata":{},"sourceType":"module"}