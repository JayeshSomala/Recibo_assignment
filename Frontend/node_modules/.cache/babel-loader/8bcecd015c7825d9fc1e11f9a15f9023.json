{"ast":null,"code":"'use strict';\n\nconst core = require('./index.js');\n\nconst EventEmitter = require('events').EventEmitter;\n\nfunction makeDoneCb(resolve, reject, localErr) {\n  return function (err, rows, fields) {\n    if (err) {\n      localErr.message = err.message;\n      localErr.code = err.code;\n      localErr.errno = err.errno;\n      localErr.sql = err.sql;\n      localErr.sqlState = err.sqlState;\n      localErr.sqlMessage = err.sqlMessage;\n      reject(localErr);\n    } else {\n      resolve([rows, fields]);\n    }\n  };\n}\n\nfunction inheritEvents(source, target, events) {\n  const listeners = {};\n  target.on('newListener', eventName => {\n    if (events.indexOf(eventName) >= 0 && !target.listenerCount(eventName)) {\n      source.on(eventName, listeners[eventName] = function () {\n        const args = [].slice.call(arguments);\n        args.unshift(eventName);\n        target.emit.apply(target, args);\n      });\n    }\n  }).on('removeListener', eventName => {\n    if (events.indexOf(eventName) >= 0 && !target.listenerCount(eventName)) {\n      source.removeListener(eventName, listeners[eventName]);\n      delete listeners[eventName];\n    }\n  });\n}\n\nclass PromisePreparedStatementInfo {\n  constructor(statement, promiseImpl) {\n    this.statement = statement;\n    this.Promise = promiseImpl;\n  }\n\n  execute(parameters) {\n    const s = this.statement;\n    const localErr = new Error();\n    return new this.Promise((resolve, reject) => {\n      const done = makeDoneCb(resolve, reject, localErr);\n\n      if (parameters) {\n        s.execute(parameters, done);\n      } else {\n        s.execute(done);\n      }\n    });\n  }\n\n  close() {\n    return new this.Promise(resolve => {\n      this.statement.close();\n      resolve();\n    });\n  }\n\n}\n\nclass PromiseConnection extends EventEmitter {\n  constructor(connection, promiseImpl) {\n    super();\n    this.connection = connection;\n    this.Promise = promiseImpl || Promise;\n    inheritEvents(connection, this, ['error', 'drain', 'connect', 'end', 'enqueue']);\n  }\n\n  release() {\n    this.connection.release();\n  }\n\n  query(query, params) {\n    const c = this.connection;\n    const localErr = new Error();\n\n    if (typeof params === 'function') {\n      throw new Error('Callback function is not available with promise clients.');\n    }\n\n    return new this.Promise((resolve, reject) => {\n      const done = makeDoneCb(resolve, reject, localErr);\n\n      if (params !== undefined) {\n        c.query(query, params, done);\n      } else {\n        c.query(query, done);\n      }\n    });\n  }\n\n  execute(query, params) {\n    const c = this.connection;\n    const localErr = new Error();\n\n    if (typeof params === 'function') {\n      throw new Error('Callback function is not available with promise clients.');\n    }\n\n    return new this.Promise((resolve, reject) => {\n      const done = makeDoneCb(resolve, reject, localErr);\n\n      if (params !== undefined) {\n        c.execute(query, params, done);\n      } else {\n        c.execute(query, done);\n      }\n    });\n  }\n\n  end() {\n    return new this.Promise(resolve => {\n      this.connection.end(resolve);\n    });\n  }\n\n  beginTransaction() {\n    const c = this.connection;\n    const localErr = new Error();\n    return new this.Promise((resolve, reject) => {\n      const done = makeDoneCb(resolve, reject, localErr);\n      c.beginTransaction(done);\n    });\n  }\n\n  commit() {\n    const c = this.connection;\n    const localErr = new Error();\n    return new this.Promise((resolve, reject) => {\n      const done = makeDoneCb(resolve, reject, localErr);\n      c.commit(done);\n    });\n  }\n\n  rollback() {\n    const c = this.connection;\n    const localErr = new Error();\n    return new this.Promise((resolve, reject) => {\n      const done = makeDoneCb(resolve, reject, localErr);\n      c.rollback(done);\n    });\n  }\n\n  ping() {\n    const c = this.connection;\n    const localErr = new Error();\n    return new this.Promise((resolve, reject) => {\n      const done = makeDoneCb(resolve, reject, localErr);\n      c.ping(done);\n    });\n  }\n\n  connect() {\n    const c = this.connection;\n    const localErr = new Error();\n    return new this.Promise((resolve, reject) => {\n      c.connect((err, param) => {\n        if (err) {\n          localErr.message = err.message;\n          localErr.code = err.code;\n          localErr.errno = err.errno;\n          localErr.sqlState = err.sqlState;\n          localErr.sqlMessage = err.sqlMessage;\n          reject(localErr);\n        } else {\n          resolve(param);\n        }\n      });\n    });\n  }\n\n  prepare(options) {\n    const c = this.connection;\n    const promiseImpl = this.Promise;\n    const localErr = new Error();\n    return new this.Promise((resolve, reject) => {\n      c.prepare(options, (err, statement) => {\n        if (err) {\n          localErr.message = err.message;\n          localErr.code = err.code;\n          localErr.errno = err.errno;\n          localErr.sqlState = err.sqlState;\n          localErr.sqlMessage = err.sqlMessage;\n          reject(localErr);\n        } else {\n          const wrappedStatement = new PromisePreparedStatementInfo(statement, promiseImpl);\n          resolve(wrappedStatement);\n        }\n      });\n    });\n  }\n\n  changeUser(options) {\n    const c = this.connection;\n    const localErr = new Error();\n    return new this.Promise((resolve, reject) => {\n      c.changeUser(options, err => {\n        if (err) {\n          localErr.message = err.message;\n          localErr.code = err.code;\n          localErr.errno = err.errno;\n          localErr.sqlState = err.sqlState;\n          localErr.sqlMessage = err.sqlMessage;\n          reject(localErr);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n\n  get config() {\n    return this.connection.config;\n  }\n\n  get threadId() {\n    return this.connection.threadId;\n  }\n\n}\n\nfunction createConnection(opts) {\n  const coreConnection = core.createConnection(opts);\n  const createConnectionErr = new Error();\n  const thePromise = opts.Promise || Promise;\n\n  if (!thePromise) {\n    throw new Error('no Promise implementation available.' + 'Use promise-enabled node version or pass userland Promise' + \" implementation as parameter, for example: { Promise: require('bluebird') }\");\n  }\n\n  return new thePromise((resolve, reject) => {\n    coreConnection.once('connect', () => {\n      resolve(new PromiseConnection(coreConnection, thePromise));\n    });\n    coreConnection.once('error', err => {\n      createConnectionErr.message = err.message;\n      createConnectionErr.code = err.code;\n      createConnectionErr.errno = err.errno;\n      createConnectionErr.sqlState = err.sqlState;\n      reject(createConnectionErr);\n    });\n  });\n} // note: the callback of \"changeUser\" is not called on success\n// hence there is no possibility to call \"resolve\"\n// patching PromiseConnection\n// create facade functions for prototype functions on \"Connection\" that are not yet\n// implemented with PromiseConnection\n// proxy synchronous functions only\n\n\n(function (functionsToWrap) {\n  for (let i = 0; functionsToWrap && i < functionsToWrap.length; i++) {\n    const func = functionsToWrap[i];\n\n    if (typeof core.Connection.prototype[func] === 'function' && PromiseConnection.prototype[func] === undefined) {\n      PromiseConnection.prototype[func] = function factory(funcName) {\n        return function () {\n          return core.Connection.prototype[funcName].apply(this.connection, arguments);\n        };\n      }(func);\n    }\n  }\n})([// synchronous functions\n'close', 'createBinlogStream', 'destroy', 'escape', 'escapeId', 'format', 'pause', 'pipe', 'resume', 'unprepare']);\n\nclass PromisePoolConnection extends PromiseConnection {\n  constructor(connection, promiseImpl) {\n    super(connection, promiseImpl);\n  }\n\n  destroy() {\n    return core.PoolConnection.prototype.destroy.apply(this.connection, arguments);\n  }\n\n}\n\nclass PromisePool extends EventEmitter {\n  constructor(pool, thePromise) {\n    super();\n    this.pool = pool;\n    this.Promise = thePromise || Promise;\n    inheritEvents(pool, this, ['acquire', 'connection', 'enqueue', 'release']);\n  }\n\n  getConnection() {\n    const corePool = this.pool;\n    return new this.Promise((resolve, reject) => {\n      corePool.getConnection((err, coreConnection) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(new PromisePoolConnection(coreConnection, this.Promise));\n        }\n      });\n    });\n  }\n\n  query(sql, args) {\n    const corePool = this.pool;\n    const localErr = new Error();\n\n    if (typeof args === 'function') {\n      throw new Error('Callback function is not available with promise clients.');\n    }\n\n    return new this.Promise((resolve, reject) => {\n      const done = makeDoneCb(resolve, reject, localErr);\n\n      if (args !== undefined) {\n        corePool.query(sql, args, done);\n      } else {\n        corePool.query(sql, done);\n      }\n    });\n  }\n\n  execute(sql, args) {\n    const corePool = this.pool;\n    const localErr = new Error();\n\n    if (typeof args === 'function') {\n      throw new Error('Callback function is not available with promise clients.');\n    }\n\n    return new this.Promise((resolve, reject) => {\n      const done = makeDoneCb(resolve, reject, localErr);\n\n      if (args) {\n        corePool.execute(sql, args, done);\n      } else {\n        corePool.execute(sql, done);\n      }\n    });\n  }\n\n  end() {\n    const corePool = this.pool;\n    const localErr = new Error();\n    return new this.Promise((resolve, reject) => {\n      corePool.end(err => {\n        if (err) {\n          localErr.message = err.message;\n          localErr.code = err.code;\n          localErr.errno = err.errno;\n          localErr.sqlState = err.sqlState;\n          localErr.sqlMessage = err.sqlMessage;\n          reject(localErr);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n\n}\n\nfunction createPool(opts) {\n  const corePool = core.createPool(opts);\n  const thePromise = opts.Promise || Promise;\n\n  if (!thePromise) {\n    throw new Error('no Promise implementation available.' + 'Use promise-enabled node version or pass userland Promise' + \" implementation as parameter, for example: { Promise: require('bluebird') }\");\n  }\n\n  return new PromisePool(corePool, thePromise);\n}\n\n(function (functionsToWrap) {\n  for (let i = 0; functionsToWrap && i < functionsToWrap.length; i++) {\n    const func = functionsToWrap[i];\n\n    if (typeof core.Pool.prototype[func] === 'function' && PromisePool.prototype[func] === undefined) {\n      PromisePool.prototype[func] = function factory(funcName) {\n        return function () {\n          return core.Pool.prototype[funcName].apply(this.pool, arguments);\n        };\n      }(func);\n    }\n  }\n})([// synchronous functions\n'escape', 'escapeId', 'format']);\n\nclass PromisePoolCluster extends EventEmitter {\n  constructor(poolCluster, thePromise) {\n    super();\n    this.poolCluster = poolCluster;\n    this.Promise = thePromise || Promise;\n    inheritEvents(poolCluster, this, ['acquire', 'connection', 'enqueue', 'release']);\n  }\n\n  getConnection() {\n    const corePoolCluster = this.poolCluster;\n    return new this.Promise((resolve, reject) => {\n      corePoolCluster.getConnection((err, coreConnection) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(new PromisePoolConnection(coreConnection, this.Promise));\n        }\n      });\n    });\n  }\n\n  query(sql, args) {\n    const corePoolCluster = this.poolCluster;\n    const localErr = new Error();\n\n    if (typeof args === 'function') {\n      throw new Error('Callback function is not available with promise clients.');\n    }\n\n    return new this.Promise((resolve, reject) => {\n      const done = makeDoneCb(resolve, reject, localErr);\n      corePoolCluster.query(sql, args, done);\n    });\n  }\n\n  execute(sql, args) {\n    const corePoolCluster = this.poolCluster;\n    const localErr = new Error();\n\n    if (typeof args === 'function') {\n      throw new Error('Callback function is not available with promise clients.');\n    }\n\n    return new this.Promise((resolve, reject) => {\n      const done = makeDoneCb(resolve, reject, localErr);\n      corePoolCluster.execute(sql, args, done);\n    });\n  }\n\n  of(pattern, selector) {\n    return new PromisePoolCluster(this.poolCluster.of(pattern, selector), this.Promise);\n  }\n\n  end() {\n    const corePoolCluster = this.poolCluster;\n    const localErr = new Error();\n    return new this.Promise((resolve, reject) => {\n      corePoolCluster.end(err => {\n        if (err) {\n          localErr.message = err.message;\n          localErr.code = err.code;\n          localErr.errno = err.errno;\n          localErr.sqlState = err.sqlState;\n          localErr.sqlMessage = err.sqlMessage;\n          reject(localErr);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n\n}\n/**\n * proxy poolCluster synchronous functions\n */\n\n\n(function (functionsToWrap) {\n  for (let i = 0; functionsToWrap && i < functionsToWrap.length; i++) {\n    const func = functionsToWrap[i];\n\n    if (typeof core.PoolCluster.prototype[func] === 'function' && PromisePoolCluster.prototype[func] === undefined) {\n      PromisePoolCluster.prototype[func] = function factory(funcName) {\n        return function () {\n          return core.PoolCluster.prototype[funcName].apply(this.poolCluster, arguments);\n        };\n      }(func);\n    }\n  }\n})(['add']);\n\nfunction createPoolCluster(opts) {\n  const corePoolCluster = core.createPoolCluster(opts);\n  const thePromise = opts && opts.Promise || Promise;\n\n  if (!thePromise) {\n    throw new Error('no Promise implementation available.' + 'Use promise-enabled node version or pass userland Promise' + \" implementation as parameter, for example: { Promise: require('bluebird') }\");\n  }\n\n  return new PromisePoolCluster(corePoolCluster, thePromise);\n}\n\nexports.createConnection = createConnection;\nexports.createPool = createPool;\nexports.createPoolCluster = createPoolCluster;\nexports.escape = core.escape;\nexports.escapeId = core.escapeId;\nexports.format = core.format;\nexports.raw = core.raw;\nexports.PromisePool = PromisePool;\nexports.PromiseConnection = PromiseConnection;\nexports.PromisePoolConnection = PromisePoolConnection;","map":{"version":3,"sources":["C:/Users/jayes/Downloads/react-hook-form-crud-example/src/_helpers/node_modules/mysql2/promise.js"],"names":["core","require","EventEmitter","makeDoneCb","resolve","reject","localErr","err","rows","fields","message","code","errno","sql","sqlState","sqlMessage","inheritEvents","source","target","events","listeners","on","eventName","indexOf","listenerCount","args","slice","call","arguments","unshift","emit","apply","removeListener","PromisePreparedStatementInfo","constructor","statement","promiseImpl","Promise","execute","parameters","s","Error","done","close","PromiseConnection","connection","release","query","params","c","undefined","end","beginTransaction","commit","rollback","ping","connect","param","prepare","options","wrappedStatement","changeUser","config","threadId","createConnection","opts","coreConnection","createConnectionErr","thePromise","once","functionsToWrap","i","length","func","Connection","prototype","factory","funcName","PromisePoolConnection","destroy","PoolConnection","PromisePool","pool","getConnection","corePool","createPool","Pool","PromisePoolCluster","poolCluster","corePoolCluster","of","pattern","selector","PoolCluster","createPoolCluster","exports","escape","escapeId","format","raw"],"mappings":"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","sourcesContent":["'use strict';\n\nconst core = require('./index.js');\nconst EventEmitter = require('events').EventEmitter;\n\nfunction makeDoneCb(resolve, reject, localErr) {\n  return function (err, rows, fields) {\n    if (err) {\n      localErr.message = err.message;\n      localErr.code = err.code;\n      localErr.errno = err.errno;\n      localErr.sql = err.sql;\n      localErr.sqlState = err.sqlState;\n      localErr.sqlMessage = err.sqlMessage;\n      reject(localErr);\n    } else {\n      resolve([rows, fields]);\n    }\n  };\n}\n\nfunction inheritEvents(source, target, events) {\n  const listeners = {};\n  target\n    .on('newListener', eventName => {\n      if (events.indexOf(eventName) >= 0 && !target.listenerCount(eventName)) {\n        source.on(\n          eventName,\n          (listeners[eventName] = function () {\n            const args = [].slice.call(arguments);\n            args.unshift(eventName);\n\n            target.emit.apply(target, args);\n          })\n        );\n      }\n    })\n    .on('removeListener', eventName => {\n      if (events.indexOf(eventName) >= 0 && !target.listenerCount(eventName)) {\n        source.removeListener(eventName, listeners[eventName]);\n        delete listeners[eventName];\n      }\n    });\n}\n\nclass PromisePreparedStatementInfo {\n  constructor(statement, promiseImpl) {\n    this.statement = statement;\n    this.Promise = promiseImpl;\n  }\n\n  execute(parameters) {\n    const s = this.statement;\n    const localErr = new Error();\n    return new this.Promise((resolve, reject) => {\n      const done = makeDoneCb(resolve, reject, localErr);\n      if (parameters) {\n        s.execute(parameters, done);\n      } else {\n        s.execute(done);\n      }\n    });\n  }\n\n  close() {\n    return new this.Promise(resolve => {\n      this.statement.close();\n      resolve();\n    });\n  }\n}\n\nclass PromiseConnection extends EventEmitter {\n  constructor(connection, promiseImpl) {\n    super();\n    this.connection = connection;\n    this.Promise = promiseImpl || Promise;\n    inheritEvents(connection, this, [\n      'error',\n      'drain',\n      'connect',\n      'end',\n      'enqueue'\n    ]);\n  }\n\n  release() {\n    this.connection.release();\n  }\n\n  query(query, params) {\n    const c = this.connection;\n    const localErr = new Error();\n    if (typeof params === 'function') {\n      throw new Error(\n        'Callback function is not available with promise clients.'\n      );\n    }\n    return new this.Promise((resolve, reject) => {\n      const done = makeDoneCb(resolve, reject, localErr);\n      if (params !== undefined) {\n        c.query(query, params, done);\n      } else {\n        c.query(query, done);\n      }\n    });\n  }\n\n  execute(query, params) {\n    const c = this.connection;\n    const localErr = new Error();\n    if (typeof params === 'function') {\n      throw new Error(\n        'Callback function is not available with promise clients.'\n      );\n    }\n    return new this.Promise((resolve, reject) => {\n      const done = makeDoneCb(resolve, reject, localErr);\n      if (params !== undefined) {\n        c.execute(query, params, done);\n      } else {\n        c.execute(query, done);\n      }\n    });\n  }\n\n  end() {\n    return new this.Promise(resolve => {\n      this.connection.end(resolve);\n    });\n  }\n\n  beginTransaction() {\n    const c = this.connection;\n    const localErr = new Error();\n    return new this.Promise((resolve, reject) => {\n      const done = makeDoneCb(resolve, reject, localErr);\n      c.beginTransaction(done);\n    });\n  }\n\n  commit() {\n    const c = this.connection;\n    const localErr = new Error();\n    return new this.Promise((resolve, reject) => {\n      const done = makeDoneCb(resolve, reject, localErr);\n      c.commit(done);\n    });\n  }\n\n  rollback() {\n    const c = this.connection;\n    const localErr = new Error();\n    return new this.Promise((resolve, reject) => {\n      const done = makeDoneCb(resolve, reject, localErr);\n      c.rollback(done);\n    });\n  }\n\n  ping() {\n    const c = this.connection;\n    const localErr = new Error();\n    return new this.Promise((resolve, reject) => {\n      const done = makeDoneCb(resolve, reject, localErr);\n      c.ping(done);\n    });\n  }\n\n  connect() {\n    const c = this.connection;\n    const localErr = new Error();\n    return new this.Promise((resolve, reject) => {\n      c.connect((err, param) => {\n        if (err) {\n          localErr.message = err.message;\n          localErr.code = err.code;\n          localErr.errno = err.errno;\n          localErr.sqlState = err.sqlState;\n          localErr.sqlMessage = err.sqlMessage;\n          reject(localErr);\n        } else {\n          resolve(param);\n        }\n      });\n    });\n  }\n\n  prepare(options) {\n    const c = this.connection;\n    const promiseImpl = this.Promise;\n    const localErr = new Error();\n    return new this.Promise((resolve, reject) => {\n      c.prepare(options, (err, statement) => {\n        if (err) {\n          localErr.message = err.message;\n          localErr.code = err.code;\n          localErr.errno = err.errno;\n          localErr.sqlState = err.sqlState;\n          localErr.sqlMessage = err.sqlMessage;\n          reject(localErr);\n        } else {\n          const wrappedStatement = new PromisePreparedStatementInfo(\n            statement,\n            promiseImpl\n          );\n          resolve(wrappedStatement);\n        }\n      });\n    });\n  }\n\n  changeUser(options) {\n    const c = this.connection;\n    const localErr = new Error();\n    return new this.Promise((resolve, reject) => {\n      c.changeUser(options, err => {\n        if (err) {\n          localErr.message = err.message;\n          localErr.code = err.code;\n          localErr.errno = err.errno;\n          localErr.sqlState = err.sqlState;\n          localErr.sqlMessage = err.sqlMessage;\n          reject(localErr);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n\n  get config() {\n    return this.connection.config;\n  }\n\n  get threadId() {\n    return this.connection.threadId;\n  }\n}\n\nfunction createConnection(opts) {\n  const coreConnection = core.createConnection(opts);\n  const createConnectionErr = new Error();\n  const thePromise = opts.Promise || Promise;\n  if (!thePromise) {\n    throw new Error(\n      'no Promise implementation available.' +\n      'Use promise-enabled node version or pass userland Promise' +\n      \" implementation as parameter, for example: { Promise: require('bluebird') }\"\n    );\n  }\n  return new thePromise((resolve, reject) => {\n    coreConnection.once('connect', () => {\n      resolve(new PromiseConnection(coreConnection, thePromise));\n    });\n    coreConnection.once('error', err => {\n      createConnectionErr.message = err.message;\n      createConnectionErr.code = err.code;\n      createConnectionErr.errno = err.errno;\n      createConnectionErr.sqlState = err.sqlState;\n      reject(createConnectionErr);\n    });\n  });\n}\n\n// note: the callback of \"changeUser\" is not called on success\n// hence there is no possibility to call \"resolve\"\n\n// patching PromiseConnection\n// create facade functions for prototype functions on \"Connection\" that are not yet\n// implemented with PromiseConnection\n\n// proxy synchronous functions only\n(function (functionsToWrap) {\n  for (let i = 0; functionsToWrap && i < functionsToWrap.length; i++) {\n    const func = functionsToWrap[i];\n\n    if (\n      typeof core.Connection.prototype[func] === 'function' &&\n      PromiseConnection.prototype[func] === undefined\n    ) {\n      PromiseConnection.prototype[func] = (function factory(funcName) {\n        return function () {\n          return core.Connection.prototype[funcName].apply(\n            this.connection,\n            arguments\n          );\n        };\n      })(func);\n    }\n  }\n})([\n  // synchronous functions\n  'close',\n  'createBinlogStream',\n  'destroy',\n  'escape',\n  'escapeId',\n  'format',\n  'pause',\n  'pipe',\n  'resume',\n  'unprepare'\n]);\n\nclass PromisePoolConnection extends PromiseConnection {\n  constructor(connection, promiseImpl) {\n    super(connection, promiseImpl);\n  }\n\n  destroy() {\n    return core.PoolConnection.prototype.destroy.apply(\n      this.connection,\n      arguments\n    );\n  }\n}\n\nclass PromisePool extends EventEmitter {\n  constructor(pool, thePromise) {\n    super();\n    this.pool = pool;\n    this.Promise = thePromise || Promise;\n    inheritEvents(pool, this, ['acquire', 'connection', 'enqueue', 'release']);\n  }\n\n  getConnection() {\n    const corePool = this.pool;\n    return new this.Promise((resolve, reject) => {\n      corePool.getConnection((err, coreConnection) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(new PromisePoolConnection(coreConnection, this.Promise));\n        }\n      });\n    });\n  }\n\n  query(sql, args) {\n    const corePool = this.pool;\n    const localErr = new Error();\n    if (typeof args === 'function') {\n      throw new Error(\n        'Callback function is not available with promise clients.'\n      );\n    }\n    return new this.Promise((resolve, reject) => {\n      const done = makeDoneCb(resolve, reject, localErr);\n      if (args !== undefined) {\n        corePool.query(sql, args, done);\n      } else {\n        corePool.query(sql, done);\n      }\n    });\n  }\n\n  execute(sql, args) {\n    const corePool = this.pool;\n    const localErr = new Error();\n    if (typeof args === 'function') {\n      throw new Error(\n        'Callback function is not available with promise clients.'\n      );\n    }\n    return new this.Promise((resolve, reject) => {\n      const done = makeDoneCb(resolve, reject, localErr);\n      if (args) {\n        corePool.execute(sql, args, done);\n      } else {\n        corePool.execute(sql, done);\n      }\n    });\n  }\n\n  end() {\n    const corePool = this.pool;\n    const localErr = new Error();\n    return new this.Promise((resolve, reject) => {\n      corePool.end(err => {\n        if (err) {\n          localErr.message = err.message;\n          localErr.code = err.code;\n          localErr.errno = err.errno;\n          localErr.sqlState = err.sqlState;\n          localErr.sqlMessage = err.sqlMessage;\n          reject(localErr);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n}\n\nfunction createPool(opts) {\n  const corePool = core.createPool(opts);\n  const thePromise = opts.Promise || Promise;\n  if (!thePromise) {\n    throw new Error(\n      'no Promise implementation available.' +\n      'Use promise-enabled node version or pass userland Promise' +\n      \" implementation as parameter, for example: { Promise: require('bluebird') }\"\n    );\n  }\n\n  return new PromisePool(corePool, thePromise);\n}\n\n(function (functionsToWrap) {\n  for (let i = 0; functionsToWrap && i < functionsToWrap.length; i++) {\n    const func = functionsToWrap[i];\n\n    if (\n      typeof core.Pool.prototype[func] === 'function' &&\n      PromisePool.prototype[func] === undefined\n    ) {\n      PromisePool.prototype[func] = (function factory(funcName) {\n        return function () {\n          return core.Pool.prototype[funcName].apply(this.pool, arguments);\n        };\n      })(func);\n    }\n  }\n})([\n  // synchronous functions\n  'escape',\n  'escapeId',\n  'format'\n]);\n\nclass PromisePoolCluster extends EventEmitter {\n  constructor(poolCluster, thePromise) {\n    super();\n    this.poolCluster = poolCluster;\n    this.Promise = thePromise || Promise;\n    inheritEvents(poolCluster, this, ['acquire', 'connection', 'enqueue', 'release']);\n  }\n\n  getConnection() {\n    const corePoolCluster = this.poolCluster;\n    return new this.Promise((resolve, reject) => {\n      corePoolCluster.getConnection((err, coreConnection) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(new PromisePoolConnection(coreConnection, this.Promise));\n        }\n      });\n    });\n  }\n\n  query(sql, args) {\n    const corePoolCluster = this.poolCluster;\n    const localErr = new Error();\n    if (typeof args === 'function') {\n      throw new Error(\n        'Callback function is not available with promise clients.'\n      );\n    }\n    return new this.Promise((resolve, reject) => {\n      const done = makeDoneCb(resolve, reject, localErr);\n      corePoolCluster.query(sql, args, done);\n    });\n  }\n\n  execute(sql, args) {\n    const corePoolCluster = this.poolCluster;\n    const localErr = new Error();\n    if (typeof args === 'function') {\n      throw new Error(\n        'Callback function is not available with promise clients.'\n      );\n    }\n    return new this.Promise((resolve, reject) => {\n      const done = makeDoneCb(resolve, reject, localErr);\n      corePoolCluster.execute(sql, args, done);\n    });\n  }\n\n  of(pattern, selector) {\n    return new PromisePoolCluster(\n      this.poolCluster.of(pattern, selector),\n      this.Promise\n    );\n  }\n\n  end() {\n    const corePoolCluster = this.poolCluster;\n    const localErr = new Error();\n    return new this.Promise((resolve, reject) => {\n      corePoolCluster.end(err => {\n        if (err) {\n          localErr.message = err.message;\n          localErr.code = err.code;\n          localErr.errno = err.errno;\n          localErr.sqlState = err.sqlState;\n          localErr.sqlMessage = err.sqlMessage;\n          reject(localErr);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n}\n\n/**\n * proxy poolCluster synchronous functions\n */\n(function (functionsToWrap) {\n  for (let i = 0; functionsToWrap && i < functionsToWrap.length; i++) {\n    const func = functionsToWrap[i];\n\n    if (\n      typeof core.PoolCluster.prototype[func] === 'function' &&\n      PromisePoolCluster.prototype[func] === undefined\n    ) {\n      PromisePoolCluster.prototype[func] = (function factory(funcName) {\n        return function () {\n          return core.PoolCluster.prototype[funcName].apply(this.poolCluster, arguments);\n        };\n      })(func);\n    }\n  }\n})([\n  'add'\n]);\n\nfunction createPoolCluster(opts) {\n  const corePoolCluster = core.createPoolCluster(opts);\n  const thePromise = (opts && opts.Promise) || Promise;\n  if (!thePromise) {\n    throw new Error(\n      'no Promise implementation available.' +\n      'Use promise-enabled node version or pass userland Promise' +\n      \" implementation as parameter, for example: { Promise: require('bluebird') }\"\n    );\n  }\n  return new PromisePoolCluster(corePoolCluster, thePromise);\n}\n\nexports.createConnection = createConnection;\nexports.createPool = createPool;\nexports.createPoolCluster = createPoolCluster;\nexports.escape = core.escape;\nexports.escapeId = core.escapeId;\nexports.format = core.format;\nexports.raw = core.raw;\nexports.PromisePool = PromisePool;\nexports.PromiseConnection = PromiseConnection;\nexports.PromisePoolConnection = PromisePoolConnection;\n"]},"metadata":{},"sourceType":"module"}